app/main.py
import os
from dotenv import load_dotenv
# Load environment variables from the .env file
load_dotenv()
config_path = os.environ.get('GLOBAL_CONFIG_FILE')

from flask import Flask, render_template, request
import uvicorn
from asgiref.wsgi import WsgiToAsgi
from app.routes.routes import api
from app.interface.gradio import create_interface
from logging_config import logger
from app.livechat import livechat_bp, socketio
from app.chatbot.routes.chatbot_routes import chatbot_bp

# Log an informational message
logger.info("Hello, world!")

# Create a Flask application instance
app = Flask(__name__)
# Register the routes blueprints
app.register_blueprint(api)
app.register_blueprint(livechat_bp, url_prefix='/livechat')
app.register_blueprint(chatbot_bp, url_prefix='/chatbot')

socketio.init_app(app)

# Create the Gradio interface for the chatbot
interface = create_interface()

# Define routes and view functions here

if __name__ == "__main__":
    # Get the port number from the environment variable or use the default value
    port = int(os.environ.get("PORT", 7860))

    if os.environ.get("FLASK_ENV") == "development":
        app.run(host="0.0.0.0", port=port)
    else:
        interface.launch()  # Launch the Gradio interface
        uvicorn.run(WsgiToAsgi(app), host="0.0.0.0", port=port, log_level="info")
-
app/chatbot/routes/chatbot_routes.py
#./app/chatbot/routes/chatbot_routes.py
from flask import Blueprint, jsonify, request
from app.chatbot.conversation_handler import ConversationHandler
from app.chatbot.bot_config import BotConfig

# Initialize the BotConfig instance with the config file
bot_config = BotConfig()

# Initialize the ConversationHandler instance with the bot configuration
conversation_handler = ConversationHandler(bot_config)

# Create a Blueprint object for route handling
chatbot_bp = Blueprint("chatbot_routes", __name__, url_prefix="/chatbot")

# Route for handling chatbot requests
@chatbot_bp.route('/chatbot', methods=['POST'])
def chatbot_route():
    request_data = request.json
    user_input = request_data['user_input']
    chatbot_id = request_data['chatbot_id']
    conversation_history = request_data['conversation_history']
    response = conversation_handler.handle_conversation(user_input, chatbot_id, conversation_history)
    return jsonify({'response': response})

-
app/chatbot/routes/chatbot_routes.py
#./app/chatbot/routes/chatbot_routes.py
from flask import Blueprint, jsonify, request
from app.chatbot.conversation_handler import ConversationHandler
from app.chatbot.bot_config import BotConfig

# Initialize the BotConfig instance with the config file
bot_config = BotConfig()

# Initialize the ConversationHandler instance with the bot configuration
conversation_handler = ConversationHandler(bot_config)

# Create a Blueprint object for route handling
chatbot_bp = Blueprint("chatbot_routes", __name__, url_prefix="/chatbot")

# Route for handling chatbot requests
@chatbot_bp.route('/chatbot', methods=['POST'])
def chatbot_route():
    request_data = request.json
    user_input = request_data['user_input']
    chatbot_id = request_data['chatbot_id']
    conversation_history = request_data['conversation_history']
    response = conversation_handler.handle_conversation(user_input, chatbot_id, conversation_history)
    return jsonify({'response': response})

-
app/chatbot/__init__.py

-
app/chatbot/bot_config.py
#./app/chatbot/bot_config.py

import os
import yaml
from dotenv import load_dotenv
# Load environment variables from the .env file
load_dotenv()

class BotConfig:
    def __init__(self, config_file_path=None):
        if config_file_path is None:
            config_file_path = os.environ.get('GLOBAL_CONFIG_FILE')

        with open(config_file_path, 'r') as config_file:
            self.config = yaml.safe_load(config_file)

    def get_config(self, key):
        return self.config.get(key)
    
    def get_api_key(self):
        return os.environ.get('OPEN_AI_API_KEY')
-
app/chatbot/chatbot.py
#./app/chatbot/chatbot.py
from .bot_config import BotConfig
from .conversation_handler import ConversationHandler
from .messaging_manager import MessagingManager
from .prompt_builder import PromptBuilder
from .response_handler import ResponseHandler

class Chatbot:
    def __init__(self, config_file_path):
        bot_config = BotConfig(config_file_path)
        self.conversation_handler = ConversationHandler(bot_config)
        self.messaging_manager = MessagingManager(bot_config)
        self.prompt_builder = PromptBuilder(bot_config)
        self.response_handler = ResponseHandler(bot_config)

    def response(self, user_input, chatbot_id, conversation_history):
        conversation = self.conversation_handler.get_conversation(chatbot_id, conversation_history)
        prompt = self.prompt_builder.build_prompt(conversation, user_input)
        response = self.messaging_manager.send_message(prompt)
        processed_response = self.response_handler.process_response(response)
        self.conversation_handler.update_conversation(chatbot_id, user_input, processed_response)
        return processed_response

-
app/chatbot/conversation_handler.py
#./app/chatbot/conversation_handler.py
from app.chatbot.bot_config import BotConfig
from .messaging_manager import MessagingManager

class ConversationHandler:
    def __init__(self, bot_config):
        self.messaging_manager = MessagingManager(bot_config)

    def handle_conversation(self, user_input, chatbot_id, conversation_history):
        return self.messaging_manager.generate_response(user_input, chatbot_id, conversation_history)

    def start_conversation(self, user_input):
        # Add the user's input to the conversation history
        self.conversation_history.append({
            "user": self.bot_config.get_config("user_name"),
            "input": user_input,
            "chatbot": self.bot_config.get_config("chatbot_name"),
            "response": "",
        })

        # Build the conversation prompt
        prompt = self.messaging_manager.build_prompt(user_input, self.conversation_history)

        # Get the chatbot's response
        chatbot_response = self.messaging_manager.get_chatbot_response(prompt, self.bot_config.get_config("chatbot_id"))

        # Add the chatbot's response to the conversation history
        self.conversation_history[-1]["response"] = chatbot_response

        return chatbot_response

-
app/chatbot/messaging_manager.py
#./app/chatbot/messaging_manager.py
from app.chatbot.prompt_builder import PromptBuilder
import openai
import requests

class MessagingManager:
    def __init__(self, bot_config):
        self.bot_config = bot_config
        self.api_key = self.bot_config.get_api_key()

    def send_message(self, message, chatbot_id):
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {self.api_key}'
        }
        payload = {
            'prompt': message,
            'temperature': self.bot_config.get_config('temperature'),
            'max_tokens': self.bot_config.get_config('max_tokens'),
            'top_p': self.bot_config.get_config('top_p'),
            'frequency_penalty': self.bot_config.get_config('frequency_penalty'),
            'presence_penalty': self.bot_config.get_config('presence_penalty'),
            'stop': self.bot_config.get_config('stop')
        }
        response = requests.post(
            f'https://api.openai.com/v1/chatbots/{chatbot_id}/messages',
            headers=headers,
            json=payload
        )
        response_data = response.json()
        if response.status_code != 200:
            error_message = response_data.get('error', {}).get('message', 'Unknown error')
            raise ValueError(f'Failed to send message to chatbot: {error_message}')
        return response_data['choices'][0]['text']
-
app/chatbot/prompt_builder.py
# Define the PromptBuilder class for constructing conversation prompts
class PromptBuilder:
    def __init__(self, bot_config, user_input=None):
        self.bot_config = bot_config
        self.user_input = user_input
        self.conversation_history = []

    # Function to get chatbot configuration by ID, merging with the default chatbot if available
    def get_chatbot_by_id(chatbot_id, config):
        default_chatbot = None
        target_chatbot = None

        # Iterate through chatbots to find the default and target chatbots
        for chatbot in config['chatbots']:
            if chatbot['id'] == 'default':
                default_chatbot = chatbot
            if chatbot['id'] == chatbot_id:
                target_chatbot = chatbot

        # If both default and target chatbots are found, merge their configurations
        if default_chatbot and target_chatbot:
            merged_chatbot = {**default_chatbot, **target_chatbot}
            return merged_chatbot
        return None
    
    # Function to build the conversation prompt
    def build_prompt(self):
        # Set of default keys for chatbot configuration
        default_keys = set([
            "id", "name", "human", "pronouns", "job", "personality", "directive",
            "likes", "dialect", "intro", "greeting"
        ])

        # If there is no conversation history, use the chatbot's intro and greeting
        if not self.conversation_history:
            prompt = self.chatbot['intro'].format(**self.chatbot)

            # Add any additional chatbot traits to the prompt
            additional_traits = {k: v for k, v in self.chatbot.items() if k not in default_keys}

            if additional_traits:
                prompt += "\n\nExtra traits:"
                for key, value in additional_traits.items():
                    prompt += f" - {key.capitalize()}: {value}"

            prompt += f"\n\n{self.chatbot['greeting'].format(**self.chatbot)}"
        else:
            prompt = ""

        # Add conversation history to the prompt
        for turn in self.conversation_history:
            prompt += f"\n\n{turn['user']}: {turn['input']}"
            prompt += f"\n\n{turn['chatbot']}: {turn['response']}"

        # Add the user's input to the prompt
        prompt += f"\n\n{self.chatbot['human']}: {self.user_input}"

        return prompt

-
app/chatbot/response_handler.py
#./app/chatbot/response_handler.py
class ResponseHandler:
    def __init__(self, bot_config):
        self.bot_config = bot_config
        self.bot_name = self.bot_config.get_config("bot_name")

    def process_response(self, response):
        # Remove the chatbot's name from the response, if it is present
        if response.startswith(self.bot_name + ":"):
            response = response[len(self.bot_name) + 1:].strip()

        return response

-
app/interface/gradio.py
import gradio as gr
from app.chatbot.routes.chatbot_routes import Chatbot

# Initialize the Chatbot instance with a configuration file
chatbot = Chatbot('config.yaml')

# Function to get a chatbot response based on user input, chatbot_id, and conversation history
def chatbot_response(user_input, chatbot_id="serendipity-fairy", conversation_history=None):
    # Generate a response using the Chatbot instance
    response = chatbot.response(user_input, chatbot_id, conversation_history)
    return response

# Function to create a Gradio interface for the chatbot
def create_interface():
    # Define the Gradio interface with input, output, title, and other information
    iface = gr.Interface(
        fn=chatbot_response,  # Function to call for generating chatbot responses
        inputs=[
        gr.components.Textbox(lines=2, label="Your message"),
        gr.components.Radio(choices=["serendipity-fairy", "serendipity-assistant"], label="Chatbot")
         ],
        outputs=gr.components.Textbox(label="Chatbot's response"),
        title="AI Chatbot",  # Title of the interface
        description="A chatbot with different personalities.",  # Description of the interface
        examples=[  # Example inputs and responses for users
            ["Can you tell me a joke?", "Sure, why did the tomato turn red? Because it saw the salad dressing!"],
            ["What's your favorite color?", "I don't have eyes, so I don't have a favorite color."]
        ]
    )
    return iface

-
app/livechat/__init__.py
from flask import Blueprint
from flask_socketio import SocketIO

livechat_bp = Blueprint('livechat', __name__)
socketio = SocketIO()

from . import routes, events

-
app/livechat/events.py
from flask_socketio import join_room, leave_room, send
from . import socketio

@socketio.on('join')
def on_join(data):
    username = data['username']
    room = data['room']
    join_room(room)
    send(username + ' has entered the room.', room=room)

@socketio.on('leave')
def on_leave(data):
    username = data['username']
    room = data['room']
    leave_room(room)
    send(username + ' has left the room.', room=room)

@socketio.on('message')
def on_message(data):
    send(data['message'], room=data['room'])
-
app/livechat/livechat.py

-
app/livechat/routes.py
from flask import render_template
from . import livechat_bp

@livechat_bp.route('/')
def livechat():
    return render_template('livechat.html')
-
