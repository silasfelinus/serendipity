# Serendipity Functions and Classes
.\trawler.py
- def read_gitignore():
- def traverse_directory(gitignore_set, output_file, dir_path="."):
- def main():

app\logging_config.py
- def setup_logging():
# Create a logger object

app\utils.py
# Load configurations from global_config_file and bot_presets_file
- def load_config(global_config_file, bot_presets_file):
- def generate_response(prompt, config):

app\chatbot\chatbot.py
# Import the generate_response function from the response module
- class Chatbot:
- def __init__(self, config_file, chatbot_id="default"):
- def load_config(self):
- def response(self, user_input, chatbot_id):

app\chatbot\conversation.py
# Import the PromptBuilder class
- def build_prompt(chatbot, user_input, conversation_history=None):

app\chatbot\prompt_builder.py
# Define the PromptBuilder class for constructing conversation prompts
- class PromptBuilder:
- def __init__(self, chatbot, user_input, conversation_history=None):
- def get_chatbot_by_id(chatbot_id, config):
- default_chatbot = None
- default_chatbot = chatbot
- def build_prompt(self):
- default_keys = set([

app\chatbot\response.py
# Set the OpenAI API key
- def generate_response(prompt):

app\interface\gradio.py
# Initialize the Chatbot instance with a configuration file
- def chatbot_response(user_input, chatbot_id="serendipity-fairy", conversation_history=None):
- def create_interface():

app\routes\routes.py
# app/routes/routes.py
- def main_page():
- def chatbot_route():

app\test\test_main.py
# app/test/test_main.py
- def client():
- def test_main_route(client):
- def test_logger():
- def test_create_interface(mocker):

app\utils\utils.py
# Load configurations from global_config_file and bot_presets_file
- def load_config(global_config_file, bot_presets_file):
- def generate_response(prompt, config):

venv\Lib\site-packages\cycler.py
- def _process_keys(left, right):
- def concat(left, right):
- class Cycler:
- def __call__(self):
- def __init__(self, left, right=None, op=None):
# Need to copy the dictionary or else that will be a residual
- def __contains__(self, k):
- def keys(self):
- def change_key(self, old, new):
- def _from_iter(cls, label, itr):
- def __getitem__(self, key):
- def __iter__(self):
- def __add__(self, other):
- def __mul__(self, other):
- def __rmul__(self, other):
- def __len__(self):
- def __iadd__(self, other):
- def __imul__(self, other):
- def __eq__(self, other):
- def __ne__(self, other):
- def __repr__(self):
- def _repr_html_(self):
- def by_key(self):
- def simplify(self):
- def cycler(*args, **kwargs):
- def _cycler(label, itr):

venv\Lib\site-packages\entrypoints.py
# Copyright (c) Thomas Kluyver and contributors
- class BadEntryPoint(Exception):
- def __init__(self, epstr):
- def __str__(self):
- def err_to_warnings():
- class NoSuchEntryPoint(Exception):
- def __init__(self, group, name):
- def __str__(self):
- class CaseSensitiveConfigParser(configparser.ConfigParser):
- class EntryPoint(object):
- def __init__(self, name, module_name, object_name, extras=None, distro=None):
- def __repr__(self):
- def load(self):
- def from_string(cls, epstr, name, distro=None):
- class Distribution(object):
- def __init__(self, name, version):
- def from_name_version(cls, name):
- def __repr__(self):
- def iter_files_distros(path=None, repeated_distro='first'):
- def get_single(group, name, path=None):
- def get_group_named(group, path=None):
- def get_group_all(group, path=None):

venv\Lib\site-packages\ffmpy.py
- class FFmpeg(object):
- def __init__(
- def __repr__(self):
- def run(self, input_data=None, stdout=None, stderr=None, env=None):
- class FFprobe(FFmpeg):
- def __init__(self, executable="ffprobe", global_options="", inputs=None):
- class FFExecutableNotFoundError(Exception):
- class FFRuntimeError(Exception):
- def __init__(self, cmd, exit_code, stdout, stderr):
- def _is_sequence(obj):
- def _merge_args_opts(args_opts_dict, **kwargs):

venv\Lib\site-packages\pkgutil_resolve_name.py
- def resolve_name(name):
# Lazy import to speedup Python startup time

venv\Lib\site-packages\six.py
# Copyright (c) 2010-2020 Benjamin Peterson
- class_types = type,
- class_types = (type, types.ClassType)
- class X(object):
- def __len__(self):
- def _add_doc(func, doc):
- def _import_module(name):
- class _LazyDescr(object):
- def __init__(self, name):
- def __get__(self, obj, tp):
- class MovedModule(_LazyDescr):
- def __init__(self, name, old, new=None):
- def _resolve(self):
- def __getattr__(self, attr):
- class _LazyModule(types.ModuleType):
- def __init__(self, name):
- def __dir__(self):
- class MovedAttribute(_LazyDescr):
- def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
- def _resolve(self):
- class _SixMetaPathImporter(object):
- def __init__(self, six_module_name):
- def _add_module(self, mod, *fullnames):
- def _get_module(self, fullname):
- def find_module(self, fullname, path=None):
- def find_spec(self, fullname, path, target=None):
- def __get_module(self, fullname):
- def load_module(self, fullname):
- def is_package(self, fullname):
- def get_code(self, fullname):
- def create_module(self, spec):
- def exec_module(self, module):
- class _MovedItems(_LazyModule):
- class Module_six_moves_urllib_parse(_LazyModule):
- class Module_six_moves_urllib_error(_LazyModule):
- class Module_six_moves_urllib_request(_LazyModule):
- class Module_six_moves_urllib_response(_LazyModule):
- class Module_six_moves_urllib_robotparser(_LazyModule):
- class Module_six_moves_urllib(types.ModuleType):
- def __dir__(self):
- def add_move(move):
- def remove_move(name):
- def advance_iterator(it):
- def callable(obj):
- def get_unbound_function(unbound):
- def create_unbound_method(func, cls):
- def get_unbound_function(unbound):
- def create_bound_method(func, obj):
- def create_unbound_method(func, cls):
- class Iterator(object):
- def next(self):
- def iterkeys(d, **kw):
- def itervalues(d, **kw):
- def iteritems(d, **kw):
- def iterlists(d, **kw):
- def iterkeys(d, **kw):
- def itervalues(d, **kw):
- def iteritems(d, **kw):
- def iterlists(d, **kw):
- def b(s):
- def u(s):
- def b(s):
- def u(s):
- def byte2int(bs):
- def indexbytes(buf, i):
- def assertCountEqual(self, *args, **kwargs):
- def assertRaisesRegex(self, *args, **kwargs):
- def assertRegex(self, *args, **kwargs):
- def assertNotRegex(self, *args, **kwargs):
- def reraise(tp, value, tb=None):
- def exec_(_code_, _globs_=None, _locs_=None):
- def raise_from(value, from_value):
- def print_(*args, **kwargs):
- def write(data):
- def print_(*args, **kwargs):
- def _update_wrapper(wrapper, wrapped,
- def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
- def with_metaclass(meta, *bases):
- class metaclass(type):
- def __new__(cls, name, this_bases, d):
- def __prepare__(cls, name, this_bases):
- def add_metaclass(metaclass):
- def wrapper(cls):
- def ensure_binary(s, encoding='utf-8', errors='strict'):
- def ensure_str(s, encoding='utf-8', errors='strict'):
- def ensure_text(s, encoding='utf-8', errors='strict'):
- def python_2_unicode_compatible(klass):

venv\Lib\site-packages\typing_extensions.py
# Super-special typing primitives.
- def _check_generic(cls, parameters, elen=_marker):
- def _should_collect_from_parameters(t):
- def _should_collect_from_parameters(t):
- def _should_collect_from_parameters(t):
- def _collect_type_vars(types, typevar_types=None):
- class _AnyMeta(type):
- def __instancecheck__(self, obj):
- def __repr__(self):
- class Any(metaclass=_AnyMeta):
- def __new__(cls, *args, **kwargs):
- class _FinalForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- def __getitem__(self, parameters):
- class Connection:
- class FastConnector(Connection):
- def final(f):
- class Base:
- def done(self) -> None:
- class Sub(Base):
- def done(self) -> None:  # Error reported by type checker
- class Leaf:
- class Other(Leaf):  # Error reported by type checker
- def IntVar(name):
- class _LiteralForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- def __getitem__(self, parameters):
- def overload(func):
- def utf8(value: None) -> None: ...
- def utf8(value: bytes) -> bytes: ...
- def utf8(value: str) -> bytes: ...
- def utf8(value: None) -> None: ...
- def utf8(value: bytes) -> bytes: ...
- def utf8(value: str) -> bytes: ...
- def utf8(value):
- def get_overloads(func):
- def clear_overloads():
- def _get_protocol_attrs(cls):
- def _is_callable_members_only(cls):
- def _maybe_adjust_parameters(cls):
- def _no_init(self, *args, **kwargs):
- class _ProtocolMeta(abc.ABCMeta):  # noqa: B024
- def __instancecheck__(cls, instance):
- class Protocol(metaclass=_ProtocolMeta):
- class Proto(Protocol):
- def meth(self) -> int:
- class C:
- def meth(self) -> int:
- def func(x: Proto) -> int:
- class GenProto(Protocol[T]):
- def meth(self) -> T:
- def __new__(cls, *args, **kwds):
- def __class_getitem__(cls, params):
- def __init_subclass__(cls, *args, **kwargs):
- def _proto_hook(other):
- def runtime_checkable(cls):
- class SupportsIndex(Protocol):
- def __index__(self) -> int:
- def _check_fails(cls, other):
- def _dict_new(*args, **kwargs):
- def _typeddict_new(*args, total=True, **kwargs):
- class _TypedDictMeta(type):
- def __init__(cls, name, bases, ns, total=True):
- def __new__(cls, name, bases, ns, total=True):
- class Point2D(TypedDict):
- def is_typeddict(tp):
- class Film(TypedDict):
- def assert_type(__val, __typ):
- def greet(name: str) -> None:
- def _strip_extras(t):
- def get_type_hints(obj, globalns=None, localns=None, include_extras=False):
- default value equal to None is set and recursively replaces all
- class _AnnotatedAlias(typing._GenericAlias, _root=True):
- def __init__(self, origin, metadata):
- def copy_with(self, params):
- def __repr__(self):
- def __reduce__(self):
- def __eq__(self, other):
- def __hash__(self):
- class Annotated:
- def __new__(cls, *args, **kwargs):
- def __class_getitem__(cls, params):
- def __init_subclass__(cls, *args, **kwargs):
- def get_origin(tp):
- def get_args(tp):
- class _TypeAliasForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- def TypeAlias(self, parameters):
- class _TypeAliasForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- class _DefaultMixin:
- def __init__(self, default):
- class TypeVar(typing.TypeVar, _DefaultMixin, _root=True):
- def __init__(self, name, *constraints, bound=None,
- default=_marker, infer_variance=False):
- def_mod = sys._getframe(1).f_globals.get('__name__', '__main__')
- def_mod = None
- class _Immutable:
- def __copy__(self):
- def __deepcopy__(self, memo):
- class ParamSpecArgs(_Immutable):
- def __init__(self, origin):
- def __repr__(self):
- def __eq__(self, other):
- class ParamSpecKwargs(_Immutable):
- def __init__(self, origin):
- def __repr__(self):
- def __eq__(self, other):
- class ParamSpec(typing.ParamSpec, _DefaultMixin, _root=True):
- def __init__(self, name, *, bound=None, covariant=False, contravariant=False,
- default=_marker):
- def_mod = sys._getframe(1).f_globals.get('__name__', '__main__')
- def_mod = None
- class ParamSpec(list, _DefaultMixin):
- def add_logging(f: Callable[P, T]) -> Callable[P, T]:
- def inner(*args: P.args, **kwargs: P.kwargs) -> T:
- def add_two(x: float, y: float) -> float:
- def args(self):
- def kwargs(self):
- def __init__(self, name, *, bound=None, covariant=False, contravariant=False,
- default=_marker):
- def_mod = sys._getframe(1).f_globals.get('__name__', '__main__')
- def_mod = None
- def __repr__(self):
- def __hash__(self):
- def __eq__(self, other):
- def __reduce__(self):
- def __call__(self, *args, **kwargs):
- class _ConcatenateGenericAlias(list):
- def __init__(self, origin, args):
- def __repr__(self):
- def __hash__(self):
- def __call__(self, *args, **kwargs):
- def __parameters__(self):
- def _concatenate_getitem(self, parameters):
- def Concatenate(self, parameters):
- class _ConcatenateForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- def __getitem__(self, parameters):
- class _TypeGuardForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- def TypeGuard(self, parameters):
- def is_str(val: Union[str, float]):
- class _TypeGuardForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- def __getitem__(self, parameters):
- def is_str(val: Union[str, float]):
- class _SpecialForm(typing._Final, _root=True):
- def __init__(self, getitem):
- def __getattr__(self, item):
- def __mro_entries__(self, bases):
- def __repr__(self):
- def __reduce__(self):
- def __call__(self, *args, **kwds):
- def __or__(self, other):
- def __ror__(self, other):
- def __instancecheck__(self, obj):
- def __subclasscheck__(self, cls):
- def __getitem__(self, parameters):
- def LiteralString(self, params):
- def query(sql: LiteralString) -> ...:
- def Self(self, params):
- class ReturnsSelf:
- def parse(self, data: bytes) -> Self:
- def Never(self, params):
- def never_call_me(arg: Never) -> None:
- def int_or_str(arg: int | str) -> None:
- class _ExtensionsSpecialForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- def Required(self, parameters):
- class Movie(TypedDict, total=False):
- def NotRequired(self, parameters):
- class Movie(TypedDict):
- class _RequiredForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- def __getitem__(self, parameters):
- class Movie(TypedDict, total=False):
- class Movie(TypedDict):
- class _UnpackSpecialForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- class _UnpackAlias(typing._GenericAlias, _root=True):
- def Unpack(self, parameters):
- def add_batch_axis(
- def _is_unpack(obj):
- class _UnpackAlias(typing._GenericAlias, _root=True):
- class _UnpackForm(typing._SpecialForm, _root=True):
- def __repr__(self):
- def __getitem__(self, parameters):
- def add_batch_axis(
- def _is_unpack(obj):
- class TypeVarTuple(typing.TypeVarTuple, _DefaultMixin, _root=True):
- def __init__(self, name, *, default=_marker):
- def_mod = sys._getframe(1).f_globals.get('__name__', '__main__')
- def_mod = None
- class TypeVarTuple(_DefaultMixin):
- class Array(Generic[*Ts]): ...
- class Array(Generic[*Ts]):
- def __init__(self, shape: Tuple[*Ts]):
- def get_shape(self) -> Tuple[*Ts]:
- def __iter__(self):
- def __init__(self, name, *, default=_marker):
- def_mod = sys._getframe(1).f_globals.get('__name__', '__main__')
- def_mod = None
- def __repr__(self):
- def __hash__(self):
- def __eq__(self, other):
- def __reduce__(self):
- def __init_subclass__(self, *args, **kwds):
- def reveal_type(__obj: T) -> T:
- def assert_never(__arg: Never) -> Never:
- def int_or_str(arg: int | str) -> None:
- def dataclass_transform(
- def create_model(cls: type[_T]) -> type[_T]:
- class CustomerModel:
- class ModelBase: ...
- class CustomerModel(ModelBase):
- class ModelMeta(type): ...
- class ModelBase(metaclass=ModelMeta): ...
- class CustomerModel(ModelBase):
- def decorator(cls_or_fn):
- def override(__arg: _F) -> _F:
- class Base:
- def method(self) -> None: ...
- class Child(Base):
- def method(self) -> None:
- def deprecated(
- class A:
- def f():
- def g(x: int) -> int: ...
- def g(x: str) -> int: ...
- def decorator(__arg: _T) -> _T:
- def __new__(cls, *args, **kwargs):
- def wrapper(*args, **kwargs):
- def _caller():
- def _make_nmtuple(name, types, module, defaults=()):
- defaults=defaults, module=module)
- class _NamedTupleMeta(type):
- def __new__(cls, typename, bases, ns):
- default_names = []
- default_names.append(field_name)
- defaults=[ns[n] for n in default_names],
- class_getitem = typing.Generic.__class_getitem__.__func__
- def NamedTuple(__typename, __fields=None, **kwargs):
- def _namedtuple_mro_entries(bases):

venv\Lib\site-packages\absl\app.py
# Copyright 2017 The Abseil Authors.
- def main(argv):
- class Error(Exception):
- class UsageError(Error):
- def __init__(self, message, exitcode=1):
- class HelpFlag(flags.BooleanFlag):
- def __init__(self):
- def parse(self, arg):
- class HelpshortFlag(HelpFlag):
- class HelpfullFlag(flags.BooleanFlag):
- def __init__(self):
- def parse(self, arg):
- class HelpXMLFlag(flags.BooleanFlag):
- def __init__(self):
- def parse(self, arg):
- def parse_flags_with_usage(args):
- def define_help_flags():
- def _register_and_parse_flags_with_usage(
- define_help_flags()
- def _run_main(main, argv):
- def _call_exception_handlers(exception):
- def run(
- def call_after_init(callback):
- def _run_init(
- def usage(shorthelp=False, writeto_stdout=False, detailed_error=None,
- class ExceptionHandler(object):
- def wants(self, exc):
- def handle(self, exc):
- def install_exception_handler(handler):

venv\Lib\site-packages\absl\command_name.py
# Copyright 2017 The Abseil Authors.
- def make_process_name_useful():
- def set_kernel_process_name(name):

venv\Lib\site-packages\absl\flags\argparse_flags.py
# Copyright 2018 The Abseil Authors.
- defines help flags unless passed with ``add_help=False``.
- class ArgumentParser(argparse.ArgumentParser):
- def __init__(self, **kwargs):
- default=argparse.SUPPRESS, help=argparse.SUPPRESS)
- default=argparse.SUPPRESS, help='show full help message and exit')
- def parse_known_args(self, args=None, namespace=None):
- def _define_absl_flags(self, absl_flags):
- def _define_absl_flag(self, flag_instance, suppress):
- class _FlagAction(argparse.Action):
- def __init__(
- default=argparse.SUPPRESS):
- default: Ignored. The flag always uses dest=argparse.SUPPRESS so it
- def __call__(self, parser, namespace, values, option_string=None):
- class _BooleanFlagAction(argparse.Action):
- def __init__(
- default=argparse.SUPPRESS):
- default: Ignored. The flag always uses dest=argparse.SUPPRESS so it
- def __call__(self, parser, namespace, values, option_string=None):
- class _HelpFullAction(argparse.Action):
- def __init__(self, option_strings, dest, default, help):  # pylint: disable=redefined-builtin
- default: Ignored.
- default=argparse.SUPPRESS,
- def __call__(self, parser, namespace, values, option_string=None):
- def _strip_undefok_args(undefok, args):
- def _is_undefok(arg, undefok_names):

venv\Lib\site-packages\absl\flags\_argument_parser.py
# Copyright 2017 The Abseil Authors.
- def _is_integer_type(instance):
- class _ArgumentParserCache(type):
- def __call__(cls, *args, **kwargs):
- class ArgumentParser(metaclass=_ArgumentParserCache):
- def parse(self, argument):
- def flag_type(self):
- def _custom_xml_dom_elements(self, doc):
- class ArgumentSerializer(object):
- def serialize(self, value):
- class NumericParser(ArgumentParser):
- def is_outside_bounds(self, val):
- def parse(self, argument):
- def _custom_xml_dom_elements(self, doc):
- def convert(self, argument):
- class FloatParser(NumericParser):
- def __init__(self, lower_bound=None, upper_bound=None):
- def convert(self, argument):
- def flag_type(self):
- class IntegerParser(NumericParser):
- def __init__(self, lower_bound=None, upper_bound=None):
- def convert(self, argument):
- def flag_type(self):
- class BooleanParser(ArgumentParser):
- def parse(self, argument):
- def flag_type(self):
- class EnumParser(ArgumentParser):
- def __init__(self, enum_values, case_sensitive=True):
- def parse(self, argument):
- def flag_type(self):
- class EnumClassParser(ArgumentParser):
- def __init__(self, enum_class, case_sensitive=True):
- def member_names(self):
- def parse(self, argument):
- def flag_type(self):
- class ListSerializer(ArgumentSerializer):
- def __init__(self, list_sep):
- def serialize(self, value):
- class EnumClassListSerializer(ListSerializer):
- def __init__(self, list_sep, **kwargs):
- def serialize(self, value):
- class CsvListSerializer(ArgumentSerializer):
- def __init__(self, list_sep):
- def serialize(self, value):
- class EnumClassSerializer(ArgumentSerializer):
- def __init__(self, lowercase):
- def serialize(self, value):
- class BaseListParser(ArgumentParser):
- def __init__(self, token=None, name=None):
- def parse(self, argument):
- def flag_type(self):
- class ListParser(BaseListParser):
- def __init__(self):
- def parse(self, argument):
- def _custom_xml_dom_elements(self, doc):
- class WhitespaceSeparatedListParser(BaseListParser):
- def __init__(self, comma_compat=False):
- def parse(self, argument):
- def _custom_xml_dom_elements(self, doc):

venv\Lib\site-packages\absl\flags\_defines.py
# Copyright 2017 The Abseil Authors.
- def _register_bounds_validator_if_needed(parser, name, flag_values):
- def checker(value):
- def DEFINE(  # pylint: disable=invalid-name
- default,
- default: The default value of the flag.
- def DEFINE_flag(  # pylint: disable=invalid-name
- def set_default(flag_holder, value):
- def _internal_declare_key_flags(flag_names,
- def declare_key_flag(flag_name, flag_values=_flagvalues.FLAGS):
- def adopt_module_key_flags(module, flag_values=_flagvalues.FLAGS):
- def disclaim_key_flags():
- define additional DEFINE_yyy functions with its own flag parsers and
- def DEFINE_string(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default,
- def DEFINE_boolean(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: bool|str|None, the default value of the flag.
- def DEFINE_float(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: float|str|None, the default value of the flag.
- default,
- def DEFINE_integer(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: int|str|None, the default value of the flag.
- default,
- def DEFINE_enum(  # pylint: disable=invalid-name,redefined-builtin
- default,
- defining enums from an `enum.Enum` class.
- default: str|None, the default value of the flag.
- def DEFINE_enum_class(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: Enum|str|None, the default value of the flag.
- default,
- def DEFINE_list(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: list|str|None, the default value of the flag.
- default,
- def DEFINE_spaceseplist(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: list|str|None, the default value of the flag.
- default,
- def DEFINE_multi(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: Union[Iterable[T], Text, None], the default value of the flag. If
- def DEFINE_multi_string(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: Union[Iterable[Text], Text, None], the default value of the flag;
- default,
- def DEFINE_multi_integer(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: Union[Iterable[int], Text, None], the default value of the flag;
- default,
- def DEFINE_multi_float(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: Union[Iterable[float], Text, None], the default value of the flag;
- default,
- def DEFINE_multi_enum(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: Union[Iterable[Text], Text, None], the default value of the flag;
- default,
- def DEFINE_multi_enum_class(  # pylint: disable=invalid-name,redefined-builtin
- default,
- default: Union[Iterable[Enum], Iterable[Text], Enum, Text, None], the
- default value of the flag; see `DEFINE_multi`; only differences are
- default,
- def DEFINE_alias(  # pylint: disable=invalid-name
- class _FlagAlias(_flag.Flag):
- def parse(self, argument):
- def _parse_from_default(self, value):
- def value(self):
- def value(self, value):

venv\Lib\site-packages\absl\flags\_exceptions.py
# Copyright 2017 The Abseil Authors.
- class Error(Exception):
- class CantOpenFlagFileError(Error):
- class DuplicateFlagError(Error):
- def from_flag(cls, flagname, flag_values, other_flag_values=None):
- class IllegalFlagValueError(Error):
- class UnrecognizedFlagError(Error):
- def __init__(self, flagname, flagvalue='', suggestions=None):
- class UnparsedFlagAccessError(Error):
- class ValidationError(Error):
- class FlagNameConflictsWithMethodError(Error):

venv\Lib\site-packages\absl\flags\_flag.py
# Copyright 2017 The Abseil Authors.
- class Flag(object):
- default: the default value for this flag
- default_unparsed: the unparsed default value for this flag.
- default_as_str: default value as repr'd string, e.g., "'true'"
- definition is replaced by the C++ flag after init
- def __init__(self, parser, serializer, name, default, help_string,
- def value(self):
- def value(self, value):
- def __hash__(self):
- def __eq__(self, other):
- def __lt__(self, other):
- def __bool__(self):
- def __getstate__(self):
- def __copy__(self):
- def __deepcopy__(self, memo):
- def _get_parsed_value_as_string(self, value):
- def parse(self, argument):
- def _parse(self, argument):
- def unparse(self):
- def serialize(self):
- def _serialize(self, value):
- def _set_default(self, value):
- def _parse_from_default(self, value):
- def flag_type(self):
- def _create_xml_dom_element(self, doc, module_name, is_key=False):
- default_serialized = self.serializer.serialize(self.default)
- default_serialized = ''
- default_serialized = self.default
- def _serialize_value_for_xml(self, value):
- def _extra_xml_dom_elements(self, doc):
- class BooleanFlag(Flag):
- def __init__(self, name, default, help, short_name=None, **args):  # pylint: disable=redefined-builtin
- class EnumFlag(Flag):
- def __init__(self, name, default, help, enum_values,  # pylint: disable=redefined-builtin
- def _extra_xml_dom_elements(self, doc):
- class EnumClassFlag(Flag):
- def __init__(
- default,
- def _extra_xml_dom_elements(self, doc):
- class MultiFlag(Flag):
- def __init__(self, *args, **kwargs):
- def parse(self, arguments):
- def _parse(self, arguments):
- def _serialize(self, value):
- def flag_type(self):
- def _extra_xml_dom_elements(self, doc):
- class MultiEnumClassFlag(MultiFlag):
- def __init__(self,
- default,
- def _extra_xml_dom_elements(self, doc):
- def _serialize_value_for_xml(self, value):

venv\Lib\site-packages\absl\flags\_flagvalues.py
# Copyright 2017 The Abseil Authors.
- class FlagValues:
- def __init__(self):
- def set_gnu_getopt(self, gnu_getopt=True):
- def is_gnu_getopt(self):
- def _flags(self):
- def flags_by_module_dict(self):
- def flags_by_module_id_dict(self):
- def key_flags_by_module_dict(self):
- def register_flag_by_module(self, module_name, flag):
- def register_flag_by_module_id(self, module_id, flag):
- def register_key_flag_for_module(self, module_name, flag):
- def _flag_is_registered(self, flag_obj):
- def _cleanup_unregistered_flag_from_module_dicts(self, flag_obj):
- def get_flags_for_module(self, module):
- def get_key_flags_for_module(self, module):
- def find_module_defining_flag(self, flagname, default=None):
- default: Value to return if flagname is not defined. Defaults to None.
- def find_module_id_defining_flag(self, flagname, default=None):
- default: Value to return if flagname is not defined. Defaults to None.
- def _register_unknown_flag_setter(self, setter):
- def _set_unknown_flag(self, name, value):
- def append_flag_values(self, flag_values):
- def remove_flag_values(self, flag_values):
- def __setitem__(self, name, flag):
- def __dir__(self):
- def __getitem__(self, name):
- def _hide_flag(self, name):
- def __getattr__(self, name):
- def __setattr__(self, name, value):
- def _set_attributes(self, **attributes):
- def validate_all_flags(self):
- def _assert_validators(self, validators):
- def __delattr__(self, flag_name):
- def set_default(self, name, value):
- def __contains__(self, name):
- def __len__(self):
- def __iter__(self):
- def __call__(self, argv, known_only=False):
- def __getstate__(self):
- def __copy__(self):
- def __deepcopy__(self, memo):
- def _set_is_retired_flag_func(self, is_retired_flag_func):
- def _parse_args(self, args, known_only):
- def get_value():
- def is_parsed(self):
- def mark_as_parsed(self):
- def unparse_flags(self):
- def flag_values_dict(self):
- def __str__(self):
- def get_help(self, prefix='', include_special_flags=True):
- def _get_help_for_modules(self, modules, prefix, include_special_flags):
- def _render_module_flags(self, module, flags, output_lines, prefix=''):
- def _render_our_module_flags(self, module, output_lines, prefix=''):
- def _render_our_module_key_flags(self, module, output_lines, prefix=''):
- def module_help(self, module):
- def main_module_help(self):
- def _render_flag_list(self, flaglist, output_lines, prefix='  '):
- def get_flag_value(self, name, default):  # pylint: disable=invalid-name
- default: Default value to use if the flag value is None.
- def _is_flag_file_directive(self, flag_string):
- def _extract_filename(self, flagfile_str):
- def _get_flag_file_lines(self, filename, parsed_file_stack=None):
- def read_flags_from_files(self, argv, force_gnu=True):
- def flags_into_string(self):
- def append_flags_into_file(self, filename):
- def write_help_in_xml_format(self, outfile=None):
- def _check_method_name_conflicts(self, name, flag):
- class FlagHolder(Generic[_T]):
- def method():
- def method():
- def __init__(self, flag_values, flag, ensure_non_none_value=False):
- def __eq__(self, other):
- def __bool__(self):
- def name(self):
- def value(self):
- def default(self):
- def present(self):
- def resolve_flag_ref(flag_ref, flag_values):
- def resolve_flag_refs(flag_refs, flag_values):

venv\Lib\site-packages\absl\flags\_helpers.py
# Copyright 2017 The Abseil Authors.
- class _ModuleObjectAndName(
- def get_module_object_and_name(globals_dict):
- def get_calling_module_object_and_name():
- def get_calling_module():
- def create_xml_dom_element(doc, name, value):
- def get_help_width():
- def get_flag_suggestions(attempt, longopt_list):
- def _damerau_levenshtein(a, b):
- def distance(x, y):
- def text_wrap(text, length=None, indent='', firstline_indent=None):
- def flag_dict_to_args(flag_map, multi_flags=None):
- def trim_docstring(docstring):
- def doc_to_help(doc):

venv\Lib\site-packages\absl\flags\_validators.py
# Copyright 2017 The Abseil Authors.
- def register_validator(flag_name,
- def validator(flag_name, message='Flag validation failed',
- def _CheckFoo(foo):
- def decorate(function):
- def register_multi_flags_validator(flag_names,
- def multi_flags_validator(flag_names,
- def _CheckFooBar(flags_dict):
- def decorate(function):
- def mark_flag_as_required(flag_name, flag_values=_flagvalues.FLAGS):
- def mark_flags_as_required(flag_names, flag_values=_flagvalues.FLAGS):
- def mark_flags_as_mutual_exclusive(flag_names, required=False,
- def validate_mutual_exclusion(flags_dict):
- def mark_bool_flags_as_mutual_exclusive(flag_names, required=False,
- def validate_boolean_mutual_exclusion(flags_dict):
- def _add_validator(fv, validator_instance):

venv\Lib\site-packages\absl\flags\_validators_classes.py
# Copyright 2021 The Abseil Authors.
- class Validator(object):
- def __init__(self, checker, message):
- def verify(self, flag_values):
- def get_flags_names(self):
- def print_flags_with_values(self, flag_values):
- def _get_input_to_checker_function(self, flag_values):
- class SingleFlagValidator(Validator):
- def __init__(self, flag_name, checker, message):
- def get_flags_names(self):
- def print_flags_with_values(self, flag_values):
- def _get_input_to_checker_function(self, flag_values):
- class MultiFlagsValidator(Validator):
- def __init__(self, flag_names, checker, message):
- def _get_input_to_checker_function(self, flag_values):
- def print_flags_with_values(self, flag_values):
- def get_flags_names(self):

venv\Lib\site-packages\absl\logging\converter.py
# Copyright 2017 The Abseil Authors.
- def get_initial_for_level(level):
- def absl_to_cpp(level):
- def absl_to_standard(level):
- def string_to_standard(level):
- def standard_to_absl(level):
- def standard_to_cpp(level):

venv\Lib\site-packages\absl\logging\__init__.py
# Copyright 2017 The Abseil Authors.
- class _VerbosityFlag(flags.Flag):
- def __init__(self, *args, **kwargs):
- def value(self):
- def value(self, v):
- def _update_logging_levels(self):
- class _LoggerLevelsFlag(flags.Flag):
- def __init__(self, *args, **kwargs):
- def value(self):
- def value(self, v):
- def _update_logger_levels(self):
- class _LoggerLevelsParser(flags.ArgumentParser):
- def parse(self, value):
- class _LoggerLevelsSerializer(object):
- def serialize(self, value):
- class _StderrthresholdFlag(flags.Flag):
- def __init__(self, *args, **kwargs):
- def value(self):
- def value(self, v):
- def get_verbosity():
- def set_verbosity(v):
- def set_stderrthreshold(s):
- def fatal(msg, *args, **kwargs):
- def error(msg, *args, **kwargs):
- def warning(msg, *args, **kwargs):
- def warn(msg, *args, **kwargs):
- def info(msg, *args, **kwargs):
- def debug(msg, *args, **kwargs):
- def exception(msg, *args, **kwargs):
- def _get_next_log_count_per_token(token):
- def log_every_n(level, msg, n, *args):
- def _seconds_have_elapsed(token, num_seconds):
- def log_every_n_seconds(level, msg, n_seconds, *args):
- def log_first_n(level, msg, n, *args):
- def log_if(level, msg, condition, *args):
- def log(level, msg, *args, **kwargs):
- def vlog(level, msg, *args, **kwargs):
- def vlog_is_on(level):
- def flush():
- def level_debug():
- def level_info():
- def level_warning():
- def level_error():
- def get_log_file_name(level=INFO):
- def find_log_dir_and_names(program_name=None, log_dir=None):
- def find_log_dir(log_dir=None):
- def get_absl_log_prefix(record):
- def skip_log_prefix(func):
- def _is_non_absl_fatal_record(log_record):
- def _is_absl_fatal_record(log_record):
- class PythonHandler(logging.StreamHandler):
- def __init__(self, stream=None, formatter=None):
- def start_logging_to_file(self, program_name=None, log_dir=None):
- def use_absl_log_file(self, program_name=None, log_dir=None):
- def flush(self):
- def _log_to_stderr(self, record):
- def emit(self, record):
- def close(self):
- class ABSLHandler(logging.Handler):
- def __init__(self, python_logging_formatter):
- def format(self, record):
- def setFormatter(self, fmt):
- def emit(self, record):
- def flush(self):
- def close(self):
- def handle(self, record):
- def python_handler(self):
- def activate_python_handler(self):
- def use_absl_log_file(self, program_name=None, log_dir=None):
- def start_logging_to_file(self, program_name=None, log_dir=None):
- class PythonFormatter(logging.Formatter):
- def format(self, record):
- class ABSLLogger(logging.getLoggerClass()):
- def findCaller(self, stack_info=False, stacklevel=1):
- def critical(self, msg, *args, **kwargs):
- def fatal(self, msg, *args, **kwargs):
- def error(self, msg, *args, **kwargs):
- def warn(self, msg, *args, **kwargs):
- def warning(self, msg, *args, **kwargs):
- def info(self, msg, *args, **kwargs):
- def debug(self, msg, *args, **kwargs):
- def log(self, level, msg, *args, **kwargs):
- def handle(self, record):
- def register_frame_to_skip(cls, file_name, function_name, line_number=None):
- def _get_thread_id():
- def get_absl_logger():
- def get_absl_handler():
- def use_python_logging(quiet=False):
- def use_absl_handler():
- def _initialize():

venv\Lib\site-packages\absl\testing\absltest.py
# Copyright 2017 The Abseil Authors.
- def expectedFailureIf(condition, reason):  # pylint: disable=invalid-name
- def test_foo(self):
- class TempFileCleanup(enum.Enum):
- def _get_default_test_random_seed():
- def get_default_test_srcdir():
- def get_default_test_tmpdir():
- def _get_default_randomize_ordering_seed():
- def _monkey_patch_test_result_for_unexpected_passes():
- def wasSuccessful(self):
- def _open(filepath, mode, _open_func=open):
- class _TempDir(object):
- def __init__(self, path):
- def full_path(self):
- def __fspath__(self):
- def create_file(self, file_path=None, content=None, mode='w', encoding='utf8',
- def mkdir(self, dir_path=None):
- class _TempFile(object):
- def __init__(self, path):
- def _create(cls, base_path, file_path, content, mode, encoding, errors):
- def full_path(self):
- def __fspath__(self):
- def read_text(self, encoding='utf8', errors='strict'):
- def read_bytes(self):
- def write_text(self, text, mode='w', encoding='utf8', errors='strict'):
- def write_bytes(self, data, mode='wb'):
- def open_text(self, mode='rt', encoding='utf8', errors='strict'):
- def open_bytes(self, mode='rb'):
- def _open(
- class _method(object):
- def __init__(self, finstancemethod):
- def classmethod(self, fclassmethod):
- def __doc__(self):
- def __get__(self, obj, type_):
- class TestCase(unittest.TestCase):
- def __init__(self, *args, **kwargs):
- def setUp(self):
- def setUpClass(cls):
- def create_tempdir(self, name=None, cleanup=None):
- def test_foo(self):
- def create_tempfile(self, file_path=None, content=None, mode='w',
- def test_foo(self):
- def enter_context(self, manager):
- class's tearDownClass call.
- def enter_context(cls, manager):  # pylint: disable=no-self-argument
- def _get_tempdir_path_cls(cls):
- def _get_tempdir_path_test(self):
- def _get_tempfile_cleanup(self, override):
- def _maybe_add_temp_path_cleanup(self, path, cleanup):
- def _internal_add_cleanup_on_success(
- def _call_cleaner_on_success(*args, **kwargs):
- def _internal_ran_and_passed_when_called_during_cleanup(
- def shortDescription(self):
- def assertStartsWith(self, actual, expected_start, msg=None):
- def assertNotStartsWith(self, actual, unexpected_start, msg=None):
- def assertEndsWith(self, actual, expected_end, msg=None):
- def assertNotEndsWith(self, actual, unexpected_end, msg=None):
- def assertSequenceStartsWith(self, prefix, whole, msg=None):
- def assertEmpty(self, container, msg=None):
- def assertNotEmpty(self, container, msg=None):
- def assertLen(self, container, expected_len, msg=None):
- def assertSequenceAlmostEqual(self, expected_seq, actual_seq, places=None,
- def assertContainsSubset(self, expected_subset, actual_set, msg=None):
- def assertNoCommonElements(self, expected_seq, actual_seq, msg=None):
- def assertItemsEqual(self, expected_seq, actual_seq, msg=None):
- def assertSameElements(self, expected_seq, actual_seq, msg=None):
- def assertMultiLineEqual(self, first, second, msg=None, **kwargs):
- def assertBetween(self, value, minv, maxv, msg=None):
- def assertRegexMatch(self, actual_str, regexes, message=None):
- def assertCommandSucceeds(self, command, regexes=(b'',), env=None,
- def assertCommandFails(self, command, regexes, env=None, close_fds=True,
- class _AssertRaisesContext(object):
- def __init__(self, expected_exception, test_case, test_func, msg=None):
- def __enter__(self):
- def __exit__(self, exc_type, exc_value, tb):
- def assertRaisesWithPredicateMatch(
- def assertRaisesWithPredicateMatch(
- def assertRaisesWithPredicateMatch(self, expected_exception, predicate,
- def Check(err):
- def assertRaisesWithLiteralMatch(
- def assertRaisesWithLiteralMatch(
- def assertRaisesWithLiteralMatch(self, expected_exception,
- def Check(err):
- def assertContainsInOrder(self, strings, target, msg=None):
- def assertContainsSubsequence(self, container, subsequence, msg=None):
- def assertContainsExactSubsequence(self, container, subsequence, msg=None):
- def assertTotallyOrdered(self, *groups, **kwargs):
- class A(object):
- def __init__(self, x, y):
- def __hash__(self):
- def __lt__(self, other):
- def CheckOrder(small, big):
- def CheckEqual(a, b):
- def assertDictEqual(self, a, b, msg=None):
- def Sorted(list_of_items):
- def Repr(dikt):
- def assertUrlEqual(self, a, b, msg=None):
- def assertSameStructure(self, a, b, aname='a', bname='b', msg=None):
- def assertJsonEqual(self, first, second, msg=None):
- def _getAssertEqualityFunc(self, first, second):
- def fail(self, msg=None, prefix=None):
- def _sorted_list_difference(expected, actual):
- def _are_both_of_integer_type(a, b):
- def _are_both_of_sequence_type(a, b):
- def _are_both_of_set_type(a, b):
- def _are_both_of_mapping_type(a, b):
- def _walk_structure_for_problems(a, b, aname, bname, problem_list):
- def get_command_string(command):
- def get_command_stderr(command, env=None, close_fds=True):
- def _quote_long_string(s):
- def print_python_version():
- def main(*args, **kwargs):
- def _is_in_app_main():
- def _register_sigterm_with_faulthandler():
- def _run_in_app(function, args, kwargs):
- def main_function(argv):
- def _is_suspicious_attribute(testCaseClass, name):
- def skipThisClass(reason):
- class BaseTest(absltest.TestCase):
- def test_simple_functionality(self):
- class RealTest(BaseTest):
- def setUp(self):
- def test_specific_behavior(self):
- class SecondRealTest(BaseTest):
- def setUp(self):
- def test_other_behavior(self):
- def _skip_class(test_case_class):
- def replacement_setupclass(cls, *args, **kwargs):
- class TestLoader(unittest.TestLoader):
- def __init__(self, *args, **kwds):
- def getTestCaseNames(self, testCaseClass):  # pylint:disable=invalid-name
- def get_default_xml_output_filename():
- def _setup_filtering(argv):
- def _setup_test_runner_fail_fast(argv):
- def _setup_sharding(custom_loader=None):
- def getShardedTestCaseNames(testCaseClass):
- def _run_and_get_tests_result(argv, args, kwargs, xml_test_runner_class):
- def run_tests(argv, args, kwargs):  # pylint: disable=line-too-long
- def _rmtree_ignore_errors(path):
- def _get_first_part(path):

venv\Lib\site-packages\absl\testing\flagsaver.py
# Copyright 2017 The Abseil Authors.
- def some_func():
- def some_func():
- def some_func():
- def some_func():
- def some_func():
- def some_func():
- def some_func():
- def flagsaver(*args: Tuple[flags.FlagHolder, Any],
- def flagsaver(func: _CallableT) -> _CallableT:
- def flagsaver(*args, **kwargs):
- def as_parsed(*args: Tuple[flags.FlagHolder, Union[str, Sequence[str]]],
- def as_parsed(func: _CallableT) -> _CallableT:
- def as_parsed(*args, **kwargs):
- def _construct_overrider(
- def _construct_overrider(flag_overrider_cls: Type['_FlagOverrider'],
- def _construct_overrider(flag_overrider_cls: Type['_FlagOverrider'],
- def _construct_overrider(flag_overrider_cls, *args, **kwargs):
- def save_flag_values(
- def restore_flag_values(saved_flag_values: Mapping[str, Mapping[str, Any]],
- def _wrap(flag_overrider_cls: Type['_FlagOverrider'], func: _CallableT,
- def _wrap(flag_overrider_cls: Type['_ParsingFlagOverrider'], func: _CallableT,
- def _wrap(flag_overrider_cls, func, overrides):
- def _flagsaver_wrapper(*args, **kwargs):
- class _FlagOverrider(object):
- def __init__(self, **overrides: Any):
- def __call__(self, func: _CallableT) -> _CallableT:
- def __enter__(self):
- def __exit__(self, exc_type, exc_value, traceback):
- class _ParsingFlagOverrider(_FlagOverrider):
- def __init__(self, **overrides: Union[str, Sequence[str]]):
- def __enter__(self):
- def _copy_flag_dict(flag: flags.Flag) -> Mapping[str, Any]:

venv\Lib\site-packages\absl\testing\parameterized.py
# Copyright 2017 The Abseil Authors.
- class AdditionExample(parameterized.TestCase):
- def testAddition(self, op1, op2, result):
- class AdditionExample(parameterized.TestCase):
- def testAddition(self, op1, op2, result):
- class NamedExample(parameterized.TestCase):
- def testStartsWith(self, prefix, string, result):
- class NamedExample(parameterized.TestCase):
- def testStartsWith(self, prefix, string, result):
- class ArithmeticTest(parameterized.TestCase):
- def testAdd(self, arg1, arg2, result):
- def testSubtract(self, arg1, arg2, result):
- class AdditionExample(parameterized.TestCase):
- def testAddition(self, op1, op2, result):
- class NegativeNumberExample(parameterized.TestCase):
- def testIsNegative(self, arg):
- class ZeroSumExample(parameterized.TestCase):
- def testSumIsZero(self, arg):
- class TestModuloExample(parameterized.TestCase):
- def testModuloResult(self, num, modulo, expected):
- def testModuloResult(self, num, modulo, expected, dtype):
- class AsyncExample(parameterized.TestCase, asynctest.TestCase):
- class NoTestsError(Exception):
- class DuplicateTestNameError(Exception):
- def __init__(self, test_class_name, new_test_name, original_test_name):
- def _clean_repr(obj):
- def _non_string_or_bytes_iterable(obj):
- def _format_parameter_list(testcase_params):
- def _async_wrapped(func):
- class _ParameterizedTestIter(object):
- def __init__(self, test_method, testcases, naming_type, original_name=None):
- def __call__(self, *args, **kwargs):
- def __iter__(self):
- def make_bound_param_test(testcase_params):
- def bound_param_test(self):
- def _modify_class(class_object, testcases, naming_type):
- class_object,))
- class_object._test_params_reprs = test_params_reprs = {}
- class_object.__name__, methods, test_params_reprs, name,
- def _parameter_decorator(naming_type, testcases):
- def _apply(obj):
- def parameters(*testcases):
- def named_parameters(*testcases):
- def product(*kwargs_seqs, **testgrid):
- class TestGeneratorMetaclass(type):
- def __new__(cls, class_name, bases, dct):
- class_name, dct, test_params_reprs, name, iterator)
- def _update_class_dict_for_param_test_case(
- class TestCase(absltest.TestCase, metaclass=TestGeneratorMetaclass):
- def _get_params_repr(self):
- def __str__(self):
- def id(self):
- def CoopTestCase(other_base_class):  # pylint: disable=invalid-name
- class ExampleTest(parameterized.CoopTestCase(OtherTestCase)):

venv\Lib\site-packages\absl\testing\xml_reporter.py
# Copyright 2017 The Abseil Authors.
- def _escape_xml_attr(content):
- def _escape_cdata(s):
- def _iso8601_timestamp(timestamp):
- def _print_xml_element_header(element, attributes, stream, indentation=''):
- class _TestCaseResult(object):
- def __init__(self, test):
- class_name = unittest.util.strclass(test.__class__)
- class_name = unittest.util.strclass(test.test_case.__class__)
- def set_run_time(self, time_in_secs):
- def set_start_time(self, time_in_secs):
- def print_xml_summary(self, stream):
- def _print_testcase_details(self, stream):
- class _TestSuiteResult(object):
- def __init__(self):
- def add_test_case_result(self, test_case_result):
- def print_xml_summary(self, stream):
- def _setup_test_suite(self, suite_name):
- def set_end_time(self, timestamp_in_secs):
- def set_start_time(self, timestamp_in_secs):
- class _TextAndXMLTestResult(_pretty_print_reporter.TextTestResult):
- def __init__(self, xml_stream, stream, descriptions, verbosity,
- def startTest(self, test):
- def stopTest(self, test):
- def startTestRun(self):
- def stopTestRun(self):
- def _exc_info_to_string(self, err, test=None):
- def add_pending_test_case_result(self, test, error_summary=None,
- def delete_pending_test_case_result(self, test):
- def get_pending_test_case_result(self, test):
- def addSuccess(self, test):
- def addError(self, test, err):
- def addFailure(self, test, err):
- def addSkip(self, test, reason):
- def addExpectedFailure(self, test, err):
- def addUnexpectedSuccess(self, test):
- def addSubTest(self, test, subtest, err):  # pylint: disable=invalid-name
- def printErrors(self):
- class TextAndXMLTestRunner(unittest.TextTestRunner):
- def __init__(self, xml_stream=None, *args, **kwargs):
- def set_default_xml_stream(cls, xml_stream):
- def _makeResult(self):
- def set_testsuites_property(cls, key, value):

venv\Lib\site-packages\absl\testing\_bazelize_command.py
# Copyright 2017 The Abseil Authors.
- def get_executable_path(py_binary_name):

venv\Lib\site-packages\absl\testing\_pretty_print_reporter.py
# Copyright 2018 The Abseil Authors.
- class TextTestResult(unittest.TextTestResult):
- def __init__(self, stream, descriptions, verbosity):
- def _print_status(self, tag, test):
- def startTest(self, test):
- def addSuccess(self, test):
- def addError(self, test, err):
- def addFailure(self, test, err):
- def addSkip(self, test, reason):
- def addExpectedFailure(self, test, err):
- def addUnexpectedSuccess(self, test):
- class TextTestRunner(unittest.TextTestRunner):
- def run(self, test):
- def _run_debug(self, test):
- def _makeResult(self):

venv\Lib\site-packages\aiofiles\base.py
- class AsyncBase:
- def __init__(self, file, loop, executor):
- def _loop(self):
- def __aiter__(self):
- def __repr__(self):
- class AsyncIndirectBase(AsyncBase):
- def __init__(self, name, loop, executor, indirect):
- def _file(self):
- def _file(self, v):
- class _ContextManager(Coroutine):
- def __init__(self, coro):
- def send(self, value):
- def throw(self, typ, val=None, tb=None):
- def close(self):
- def gi_frame(self):
- def gi_running(self):
- def gi_code(self):
- def __next__(self):
- def __iter__(self):
- def __await__(self):
- class AiofilesContextManager(_ContextManager):

venv\Lib\site-packages\aiofiles\tempfile\temptypes.py
# Imports
- class AsyncSpooledTemporaryFile(AsyncBase):
- class AsyncTemporaryDirectory:
- def __init__(self, file, loop, executor):

venv\Lib\site-packages\aiofiles\tempfile\__init__.py
# Imports
- def NamedTemporaryFile(
- def TemporaryFile(
- def SpooledTemporaryFile(
- def TemporaryDirectory(suffix=None, prefix=None, dir=None, loop=None, executor=None):
- class AiofilesContextManagerTempDir(AiofilesContextManager):
- def wrap(base_io_obj, file, *, loop=None, executor=None):
- def _(base_io_obj, file, *, loop=None, executor=None):
- def _(base_io_obj, file, *, loop=None, executor=None):
- def _(base_io_obj, file, *, loop=None, executor=None):
- def _(base_io_obj, file, *, loop=None, executor=None):

venv\Lib\site-packages\aiofiles\threadpool\binary.py
- class AsyncBufferedIOBase(AsyncBase):
- class AsyncBufferedReader(AsyncBufferedIOBase):
- class AsyncFileIO(AsyncBase):
- class AsyncIndirectBufferedIOBase(AsyncIndirectBase):
- class AsyncIndirectBufferedReader(AsyncIndirectBufferedIOBase):
- class AsyncIndirectFileIO(AsyncIndirectBase):

venv\Lib\site-packages\aiofiles\threadpool\text.py
- class AsyncTextIOWrapper(AsyncBase):
- class AsyncTextIndirectIOWrapper(AsyncIndirectBase):

venv\Lib\site-packages\aiofiles\threadpool\utils.py
- def delegate_to_executor(*attrs):
- def cls_builder(cls):
- def proxy_method_directly(*attrs):
- def cls_builder(cls):
- def proxy_property_directly(*attrs):
- def cls_builder(cls):
- def cond_delegate_to_executor(*attrs):
- def cls_builder(cls):
- def _make_delegate_method(attr_name):
- def method(self, *args, **kwargs):
- def _make_proxy_method(attr_name):
- def method(self, *args, **kwargs):
- def _make_proxy_property(attr_name):
- def proxy_property(self):
- def _make_cond_delegate_method(attr_name):

venv\Lib\site-packages\aiofiles\threadpool\__init__.py
- def open(
- def _open(
- def wrap(file, *, loop=None, executor=None):
- def _(file, *, loop=None, executor=None):
- def _(file, *, loop=None, executor=None):
- def _(file, *, loop=None, executor=None):
- def _(file, *, loop=None, executor=None):

venv\Lib\site-packages\aiohttp\abc.py
- class AbstractRouter(ABC):
- def __init__(self) -> None:
- def post_init(self, app: Application) -> None:
- def frozen(self) -> bool:
- def freeze(self) -> None:
- class AbstractMatchInfo(ABC):
- def handler(self) -> Callable[[Request], Awaitable[StreamResponse]]:
- def expect_handler(self) -> Callable[[Request], Awaitable[None]]:
- def http_exception(self) -> Optional[HTTPException]:
- def get_info(self) -> Dict[str, Any]:
- def apps(self) -> Tuple[Application, ...]:
- def add_app(self, app: Application) -> None:
- def freeze(self) -> None:
- class AbstractView(ABC):
- def __init__(self, request: Request) -> None:
- def request(self) -> Request:
- def __await__(self) -> Generator[Any, None, StreamResponse]:
- class AbstractResolver(ABC):
- class AbstractCookieJar(Sized, IterableBase):
- def __init__(self, *, loop: Optional[asyncio.AbstractEventLoop] = None) -> None:
- def clear(self, predicate: Optional[ClearCookiePredicate] = None) -> None:
- def clear_domain(self, domain: str) -> None:
- def update_cookies(self, cookies: LooseCookies, response_url: URL = URL()) -> None:
- def filter_cookies(self, request_url: URL) -> "BaseCookie[str]":
- class AbstractStreamWriter(ABC):
- def enable_compression(self, encoding: str = "deflate") -> None:
- def enable_chunking(self) -> None:
- class AbstractAccessLogger(ABC):
- def __init__(self, logger: logging.Logger, log_format: str) -> None:
- def log(self, request: BaseRequest, response: StreamResponse, time: float) -> None:

venv\Lib\site-packages\aiohttp\base_protocol.py
- class BaseProtocol(asyncio.Protocol):
- def __init__(self, loop: asyncio.AbstractEventLoop) -> None:
- def connected(self) -> bool:
- def pause_writing(self) -> None:
- def resume_writing(self) -> None:
- def pause_reading(self) -> None:
- def resume_reading(self) -> None:
- def connection_made(self, transport: asyncio.BaseTransport) -> None:
- def connection_lost(self, exc: Optional[BaseException]) -> None:
# Wake up the writer if currently paused.

venv\Lib\site-packages\aiohttp\client.py
# client_exceptions
- class ClientTimeout:
- class ClientSession:
- def __init__(
- def __init_subclass__(cls: Type["ClientSession"]) -> None:
- def __setattr__(self, name: str, val: Any) -> None:
- def __del__(self, _warnings: Any = warnings) -> None:
- def request(
- def _build_url(self, str_or_url: StrOrURL) -> URL:
- def ws_connect(
- default_headers = {
- def _prepare_headers(self, headers: Optional[LooseHeaders]) -> "CIMultiDict[str]":
- def get(
- def options(
- def head(
- def post(
- def put(
- def patch(
- def delete(self, url: StrOrURL, **kwargs: Any) -> "_RequestContextManager":
- def closed(self) -> bool:
- def connector(self) -> Optional[BaseConnector]:
- def cookie_jar(self) -> AbstractCookieJar:
- def version(self) -> Tuple[int, int]:
- def requote_redirect_url(self) -> bool:
- def requote_redirect_url(self, val: bool) -> None:
- def loop(self) -> asyncio.AbstractEventLoop:
- def timeout(self) -> ClientTimeout:
- def headers(self) -> "CIMultiDict[str]":
- def skip_auto_headers(self) -> FrozenSet[istr]:
- def auth(self) -> Optional[BasicAuth]:
- def json_serialize(self) -> JSONEncoder:
- def connector_owner(self) -> bool:
- def raise_for_status(
- def auto_decompress(self) -> bool:
- def trust_env(self) -> bool:
- def trace_configs(self) -> List[TraceConfig]:
- def detach(self) -> None:
- def __enter__(self) -> None:
- def __exit__(
- class _BaseRequestContextManager(Coroutine[Any, Any, _RetType], Generic[_RetType]):
- def __init__(self, coro: Coroutine["asyncio.Future[Any]", None, _RetType]) -> None:
- def send(self, arg: None) -> "asyncio.Future[Any]":
- def throw(self, arg: BaseException) -> None:  # type: ignore[arg-type,override]
- def close(self) -> None:
- def __await__(self) -> Generator[Any, None, _RetType]:
- def __iter__(self) -> Generator[Any, None, _RetType]:
- class _RequestContextManager(_BaseRequestContextManager[ClientResponse]):
- class _WSRequestContextManager(_BaseRequestContextManager[ClientWebSocketResponse]):
- class _SessionRequestContextManager:
- def __init__(
- def request(

venv\Lib\site-packages\aiohttp\client_exceptions.py
- class ClientError(Exception):
- class ClientResponseError(ClientError):
- def __init__(
- def __str__(self) -> str:
- def __repr__(self) -> str:
- def code(self) -> int:
- def code(self, value: int) -> None:
- class ContentTypeError(ClientResponseError):
- class WSServerHandshakeError(ClientResponseError):
- class ClientHttpProxyError(ClientResponseError):
- class TooManyRedirects(ClientResponseError):
- class ClientConnectionError(ClientError):
- class ClientOSError(ClientConnectionError, OSError):
- class ClientConnectorError(ClientOSError):
- def __init__(self, connection_key: ConnectionKey, os_error: OSError) -> None:
- def os_error(self) -> OSError:
- def host(self) -> str:
- def port(self) -> Optional[int]:
- def ssl(self) -> Union[SSLContext, None, bool, "Fingerprint"]:
- def __str__(self) -> str:
# OSError.__reduce__ does too much black magick
- class ClientProxyConnectionError(ClientConnectorError):
- class UnixClientConnectorError(ClientConnectorError):
- def __init__(
- def path(self) -> str:
- def __str__(self) -> str:
- class ServerConnectionError(ClientConnectionError):
- class ServerDisconnectedError(ServerConnectionError):
- def __init__(self, message: Union[RawResponseMessage, str, None] = None) -> None:
- class ServerTimeoutError(ServerConnectionError, asyncio.TimeoutError):
- class ServerFingerprintMismatch(ServerConnectionError):
- def __init__(self, expected: bytes, got: bytes, host: str, port: int) -> None:
- def __repr__(self) -> str:
- class ClientPayloadError(ClientError):
- class InvalidURL(ClientError, ValueError):
- def __init__(self, url: Any) -> None:
- def url(self) -> Any:
- def __repr__(self) -> str:
- class ClientSSLError(ClientConnectorError):
- class ClientConnectorSSLError(*ssl_error_bases):  # type: ignore[misc]
- class ClientConnectorCertificateError(*cert_errors_bases):  # type: ignore[misc]
- def __init__(
- def certificate_error(self) -> Exception:
- def host(self) -> str:
- def port(self) -> Optional[int]:
- def ssl(self) -> bool:
- def __str__(self) -> str:

venv\Lib\site-packages\aiohttp\client_proto.py
- class ResponseHandler(BaseProtocol, DataQueue[Tuple[RawResponseMessage, StreamReader]]):
- def __init__(self, loop: asyncio.AbstractEventLoop) -> None:
- def upgraded(self) -> bool:
- def should_close(self) -> bool:
- def force_close(self) -> None:
- def close(self) -> None:
- def is_connected(self) -> bool:
- def connection_lost(self, exc: Optional[BaseException]) -> None:
# assigns self._should_close to True as side effect,
- def eof_received(self) -> None:
- def pause_reading(self) -> None:
- def resume_reading(self) -> None:
- def set_exception(self, exc: BaseException) -> None:
- def set_parser(self, parser: Any, payload: Any) -> None:
- def set_response_params(
- def _drop_timeout(self) -> None:
- def _reschedule_timeout(self) -> None:
- def _on_read_timeout(self) -> None:
- def data_received(self, data: bytes) -> None:

venv\Lib\site-packages\aiohttp\client_reqrep.py
- class ContentDisposition:
- class RequestInfo:
- def real_url_default(self) -> URL:
- class Fingerprint:
- def __init__(self, fingerprint: bytes) -> None:
- def fingerprint(self) -> bytes:
- def check(self, transport: asyncio.Transport) -> None:
- def _merge_ssl_params(
- class ConnectionKey:
# the key should contain an information about used proxy / TLS
- def _is_expected_content_type(
- class ClientRequest:
- def __init__(
- def is_ssl(self) -> bool:
- def ssl(self) -> Union["SSLContext", None, bool, Fingerprint]:
- def connection_key(self) -> ConnectionKey:
- def host(self) -> str:
- def port(self) -> Optional[int]:
- def request_info(self) -> RequestInfo:
- def update_host(self, url: URL) -> None:
- def update_version(self, version: Union[http.HttpVersion, str]) -> None:
- def update_headers(self, headers: Optional[LooseHeaders]) -> None:
- def update_auto_headers(self, skip_auto_headers: Iterable[str]) -> None:
- def update_cookies(self, cookies: Optional[LooseCookies]) -> None:
- def update_content_encoding(self, data: Any) -> None:
- def update_transfer_encoding(self) -> None:
- def update_auth(self, auth: Optional[BasicAuth]) -> None:
- def update_body_from_data(self, body: Any) -> None:
- def update_expect_continue(self, expect: bool = False) -> None:
- def update_proxy(
- def keep_alive(self) -> bool:
- def terminate(self) -> None:
- class ClientResponse(HeadersMixin):
- def __init__(
- def url(self) -> URL:
- def url_obj(self) -> URL:
- def real_url(self) -> URL:
- def host(self) -> str:
- def headers(self) -> "CIMultiDictProxy[str]":
- def raw_headers(self) -> RawHeaders:
- def request_info(self) -> RequestInfo:
- def content_disposition(self) -> Optional[ContentDisposition]:
- def __del__(self, _warnings: Any = warnings) -> None:
- def __repr__(self) -> str:
- def connection(self) -> Optional["Connection"]:
- def history(self) -> Tuple["ClientResponse", ...]:
- def links(self) -> "MultiDictProxy[MultiDictProxy[Union[str, URL]]]":
- def _response_eof(self) -> None:
- def closed(self) -> bool:
- def close(self) -> None:
- def release(self) -> Any:
- def ok(self) -> bool:
- def raise_for_status(self) -> None:
- def _cleanup_writer(self) -> None:
- def _notify_content(self) -> None:
- def get_encoding(self) -> str:

venv\Lib\site-packages\aiohttp\client_ws.py
- class ClientWebSocketResponse:
- def __init__(
- def _cancel_heartbeat(self) -> None:
- def _reset_heartbeat(self) -> None:
- def _send_heartbeat(self) -> None:
# fire-and-forget a task is not perfect but maybe ok for
- def _pong_not_received(self) -> None:
- def closed(self) -> bool:
- def close_code(self) -> Optional[int]:
- def protocol(self) -> Optional[str]:
- def compress(self) -> int:
- def client_notakeover(self) -> bool:
- def get_extra_info(self, name: str, default: Any = None) -> Any:
- def exception(self) -> Optional[BaseException]:
- def __aiter__(self) -> "ClientWebSocketResponse":

venv\Lib\site-packages\aiohttp\connector.py
- class _DeprecationWaiter:
- def __init__(self, awaitable: Awaitable[Any]) -> None:
- def __await__(self) -> Any:
- def __del__(self) -> None:
- class Connection:
- def __init__(
- def __repr__(self) -> str:
- def __del__(self, _warnings: Any = warnings) -> None:
- def loop(self) -> asyncio.AbstractEventLoop:
- def transport(self) -> Optional[asyncio.Transport]:
- def protocol(self) -> Optional[ResponseHandler]:
- def add_callback(self, callback: Callable[[], None]) -> None:
- def _notify_release(self) -> None:
- def close(self) -> None:
- def release(self) -> None:
- def closed(self) -> bool:
- class _TransportPlaceholder:
- def close(self) -> None:
- class BaseConnector:
# abort transport after 2 seconds (cleanup broken connections)
- def __init__(
- def __del__(self, _warnings: Any = warnings) -> None:
- def __enter__(self) -> "BaseConnector":
- def __exit__(self, *exc: Any) -> None:
- def force_close(self) -> bool:
- def limit(self) -> int:
- def limit_per_host(self) -> int:
- def _cleanup(self) -> None:
- def _drop_acquired_per_host(
- def _cleanup_closed(self) -> None:
- def close(self) -> Awaitable[None]:
- def _close(self) -> None:
- def closed(self) -> bool:
- def _available_connections(self, key: "ConnectionKey") -> int:
- def _get(self, key: "ConnectionKey") -> Optional[ResponseHandler]:
- def _release_waiter(self) -> None:
- def _release_acquired(self, key: "ConnectionKey", proto: ResponseHandler) -> None:
- def _release(
- class _DNSCacheTable:
- def __init__(self, ttl: Optional[float] = None) -> None:
- def __contains__(self, host: object) -> bool:
- def add(self, key: Tuple[str, int], addrs: List[Dict[str, Any]]) -> None:
- def remove(self, key: Tuple[str, int]) -> None:
- def clear(self) -> None:
- def next_addrs(self, key: Tuple[str, int]) -> List[Dict[str, Any]]:
- def expired(self, key: Tuple[str, int]) -> bool:
- class TCPConnector(BaseConnector):
- def __init__(
- def close(self) -> Awaitable[None]:
- def family(self) -> int:
- def use_dns_cache(self) -> bool:
- def clear_dns_cache(
- def _make_ssl_context(verified: bool) -> SSLContext:
- def _get_ssl_context(self, req: "ClientRequest") -> Optional[SSLContext]:
- def _get_fingerprint(self, req: "ClientRequest") -> Optional["Fingerprint"]:
- def _fail_on_no_start_tls(self, req: "ClientRequest") -> None:
- def _check_loop_for_start_tls(self) -> None:
- def _loop_supports_start_tls(self) -> bool:
- def _warn_about_tls_in_tls(
- def drop_exception(fut: "asyncio.Future[List[Dict[str, Any]]]") -> None:
- class UnixConnector(BaseConnector):
- def __init__(
- def path(self) -> str:
- class NamedPipeConnector(BaseConnector):
- def __init__(
- def path(self) -> str:

venv\Lib\site-packages\aiohttp\cookiejar.py
- class CookieJar(AbstractCookieJar):
- def __init__(
# #4515: datetime.max may not be representable on 32-bit platforms
- def save(self, file_path: PathLike) -> None:
- def load(self, file_path: PathLike) -> None:
- def clear(self, predicate: Optional[ClearCookiePredicate] = None) -> None:
- def clear_domain(self, domain: str) -> None:
- def __iter__(self) -> "Iterator[Morsel[str]]":
- def __len__(self) -> int:
- def _do_expiration(self) -> None:
- def _expire_cookie(
- def update_cookies(self, cookies: LooseCookies, response_url: URL = URL()) -> None:
- def filter_cookies(
- def _is_domain_match(domain: str, hostname: str) -> bool:
- def _is_path_match(req_path: str, cookie_path: str) -> bool:
- def _parse_date(cls, date_str: str) -> Optional[datetime.datetime]:
- class DummyCookieJar(AbstractCookieJar):
- def __init__(self, *, loop: Optional[asyncio.AbstractEventLoop] = None) -> None:
- def __iter__(self) -> "Iterator[Morsel[str]]":
- def __len__(self) -> int:
- def clear(self, predicate: Optional[ClearCookiePredicate] = None) -> None:
- def clear_domain(self, domain: str) -> None:
- def update_cookies(self, cookies: LooseCookies, response_url: URL = URL()) -> None:
- def filter_cookies(self, request_url: URL) -> "BaseCookie[str]":

venv\Lib\site-packages\aiohttp\formdata.py
- class FormData:
- def __init__(
- def is_multipart(self) -> bool:
- def add_field(
- def add_fields(self, *fields: Any) -> None:
- def _gen_form_urlencoded(self) -> payload.BytesPayload:
# form data (x-www-form-urlencoded)
- def _gen_form_data(self) -> multipart.MultipartWriter:
- def __call__(self) -> Payload:

venv\Lib\site-packages\aiohttp\helpers.py
- def all_tasks(
# N.B. sys.flags.dev_mode is available on Python 3.7+, use getattr
- class noop:
- def __await__(self) -> Generator[None, None, None]:
- class BasicAuth(namedtuple("BasicAuth", ["login", "password", "encoding"])):
- def __new__(
- def decode(cls, auth_header: str, encoding: str = "latin1") -> "BasicAuth":
- def from_url(cls, url: URL, *, encoding: str = "latin1") -> Optional["BasicAuth"]:
- def encode(self) -> str:
- def strip_auth_from_url(url: URL) -> Tuple[URL, Optional[BasicAuth]]:
- def netrc_from_env() -> Optional[netrc.netrc]:
- class ProxyInfo:
- def proxies_from_env() -> Dict[str, ProxyInfo]:
- def current_task(
- def get_running_loop(
- def isasyncgenfunction(obj: Any) -> bool:
- def get_env_proxy_for_url(url: URL) -> Tuple[URL, Optional[BasicAuth]]:
- class MimeType:
- def parse_mimetype(mimetype: str) -> MimeType:
- def guess_filename(obj: Any, default: Optional[str] = None) -> Optional[str]:
- def quoted_string(content: str) -> str:
- def content_disposition_header(
- class _TSelf(Protocol, Generic[_T]):
- class reify(Generic[_T]):
- def __init__(self, wrapped: Callable[..., _T]) -> None:
- def __get__(self, inst: _TSelf[_T], owner: Optional[Type[Any]] = None) -> _T:
- def __set__(self, inst: _TSelf[_T], value: _T) -> None:
- def _is_ip_address(
- def is_ip_address(host: Optional[Union[str, bytes, bytearray, memoryview]]) -> bool:
- def next_whole_second() -> datetime.datetime:
- def rfc822_formatted_time() -> str:
- def _weakref_handle(info: "Tuple[weakref.ref[object], str]") -> None:
- def weakref_handle(
- def call_later(
- class TimeoutHandle:
- def __init__(
- def register(
- def close(self) -> None:
- def start(self) -> Optional[asyncio.Handle]:
- def timer(self) -> "BaseTimerContext":
- def __call__(self) -> None:
- class BaseTimerContext(ContextManager["BaseTimerContext"]):
- class TimerNoop(BaseTimerContext):
- def __enter__(self) -> BaseTimerContext:
- def __exit__(
- class TimerContext(BaseTimerContext):
- def __init__(self, loop: asyncio.AbstractEventLoop) -> None:
- def __enter__(self) -> BaseTimerContext:
- def __exit__(
- def timeout(self) -> None:
- def ceil_timeout(delay: Optional[float]) -> async_timeout.Timeout:
- class HeadersMixin:
- def _parse_content_type(self, raw: str) -> None:
- def content_type(self) -> str:
- def charset(self) -> Optional[str]:
- def content_length(self) -> Optional[int]:
- def set_result(fut: "asyncio.Future[_T]", result: _T) -> None:
- def set_exception(fut: "asyncio.Future[_T]", exc: BaseException) -> None:
- class ChainMapProxy(Mapping[str, Any]):
- def __init__(self, maps: Iterable[Mapping[str, Any]]) -> None:
- def __init_subclass__(cls) -> None:
- def __getitem__(self, key: str) -> Any:
- def get(self, key: str, default: Any = None) -> Any:
- def __len__(self) -> int:
- def __iter__(self) -> Iterator[str]:
- def __contains__(self, key: object) -> bool:
- def __bool__(self) -> bool:
- def __repr__(self) -> str:
- class ETag:
- def validate_etag_value(value: str) -> None:
- def parse_http_date(date_str: Optional[str]) -> Optional[datetime.datetime]:

venv\Lib\site-packages\aiohttp\http_exceptions.py
- class HttpProcessingError(Exception):
- def __init__(
- def __str__(self) -> str:
- def __repr__(self) -> str:
- class BadHttpMessage(HttpProcessingError):
- def __init__(self, message: str, *, headers: Optional[_CIMultiDict] = None) -> None:
- class HttpBadRequest(BadHttpMessage):
- class PayloadEncodingError(BadHttpMessage):
- class ContentEncodingError(PayloadEncodingError):
- class TransferEncodingError(PayloadEncodingError):
- class ContentLengthError(PayloadEncodingError):
- class LineTooLong(BadHttpMessage):
- def __init__(
- class InvalidHeader(BadHttpMessage):
- def __init__(self, hdr: Union[bytes, str]) -> None:
- class BadStatusLine(BadHttpMessage):
- def __init__(self, line: str = "") -> None:
- class InvalidURLError(BadHttpMessage):

venv\Lib\site-packages\aiohttp\http_parser.py
# See https://tools.ietf.org/html/rfc7230#section-3.1.1
- class RawRequestMessage(NamedTuple):
- class ParseState(IntEnum):
- class ChunkState(IntEnum):
- class HeadersParser:
- def __init__(
- def parse_headers(
- class HttpParser(abc.ABC, Generic[_MsgT]):
- def __init__(
- def parse_message(self, lines: List[bytes]) -> _MsgT:
- def feed_eof(self) -> Optional[_MsgT]:
- def feed_data(
- def get_content_length() -> Optional[int]:
- def parse_headers(
- def set_upgraded(self, val: bool) -> None:
- class HttpRequestParser(HttpParser[RawRequestMessage]):
- def parse_message(self, lines: List[bytes]) -> RawRequestMessage:
- class HttpResponseParser(HttpParser[RawResponseMessage]):
- def parse_message(self, lines: List[bytes]) -> RawResponseMessage:
- class HttpPayloadParser:
- def __init__(
- def feed_eof(self) -> None:
- def feed_data(
- class DeflateBuffer:
- def __init__(self, out: StreamReader, encoding: Optional[str]) -> None:
- class BrotliDecoder:
- def __init__(self) -> None:
- def decompress(self, data: bytes) -> bytes:
- def flush(self) -> bytes:
- def set_exception(self, exc: BaseException) -> None:
- def feed_data(self, chunk: bytes, size: int) -> None:
- def feed_eof(self) -> None:
- def begin_http_chunk_receiving(self) -> None:
- def end_http_chunk_receiving(self) -> None:

venv\Lib\site-packages\aiohttp\http_websocket.py
- class WSCloseCode(IntEnum):
- class WSMsgType(IntEnum):
# websocket spec types
- class WSMessage(_WSMessageBase):
- def json(self, *, loads: Callable[[Any], Any] = json.loads) -> Any:
- class WebSocketError(Exception):
- def __init__(self, code: int, message: str) -> None:
- def __str__(self) -> str:
- class WSHandshakeError(Exception):
- def _websocket_mask_python(mask: bytes, data: bytearray) -> None:
- def ws_ext_parse(extstr: Optional[str], isserver: bool = False) -> Tuple[int, bool]:
- defext = ext.group(1)
- def ws_ext_gen(
- class WSParserState(IntEnum):
- class WebSocketReader:
- def __init__(
- def feed_eof(self) -> None:
- def feed_data(self, data: bytes) -> Tuple[bool, bytes]:
- def _feed_data(self, data: bytes) -> Tuple[bool, bytes]:
- def parse_frame(
- class WebSocketWriter:
- def __init__(
- def _write(self, data: bytes) -> None:

venv\Lib\site-packages\aiohttp\http_writer.py
- class HttpVersion(NamedTuple):
- class StreamWriter(AbstractStreamWriter):
- def __init__(
- def transport(self) -> Optional[asyncio.Transport]:
- def protocol(self) -> BaseProtocol:
- def enable_chunking(self) -> None:
- def enable_compression(
- def _write(self, chunk: bytes) -> None:
# just reshape it
- def _safe_header(string: str) -> str:
- def _py_serialize_headers(status_line: str, headers: "CIMultiDict[str]") -> bytes:

venv\Lib\site-packages\aiohttp\locks.py
- class EventResultOrError:
- def __init__(self, loop: asyncio.AbstractEventLoop) -> None:
- def set(self, exc: Optional[BaseException] = None) -> None:
- def cancel(self) -> None:

venv\Lib\site-packages\aiohttp\multipart.py
- class BadContentDispositionHeader(RuntimeWarning):
- class BadContentDispositionParam(RuntimeWarning):
- def parse_content_disposition(
- def is_token(string: str) -> bool:
- def is_quoted(string: str) -> bool:
- def is_rfc5987(string: str) -> bool:
- def is_extended_param(string: str) -> bool:
- def is_continuous_param(string: str) -> bool:
- def unescape(text: str, *, chars: str = "".join(map(re.escape, CHAR))) -> str:
# maybe just ; in filename, in any case this is just
- def content_disposition_filename(
- class MultipartResponseWrapper:
- def __init__(
- def __aiter__(self) -> "MultipartResponseWrapper":
- def at_eof(self) -> bool:
- class BodyPartReader:
- def __init__(
- def __aiter__(self) -> AsyncIterator["BodyPartReader"]:
- def at_eof(self) -> bool:
- def decode(self, data: bytes) -> bytes:
- def _decode_content(self, data: bytes) -> bytes:
- def _decode_content_transfer(self, data: bytes) -> bytes:
- def get_charset(self, default: str) -> str:
- def name(self) -> Optional[str]:
- def filename(self) -> Optional[str]:
- class BodyPartReaderPayload(Payload):
- def __init__(self, value: BodyPartReader, *args: Any, **kwargs: Any) -> None:
- class MultipartReader:
- def __init__(self, headers: Mapping[str, str], content: StreamReader) -> None:
- def __aiter__(
- def from_response(
- def at_eof(self) -> bool:
- def _get_part_reader(
- def _get_boundary(self) -> str:
- class MultipartWriter(Payload):
- def __init__(self, subtype: str = "mixed", boundary: Optional[str] = None) -> None:
- def __enter__(self) -> "MultipartWriter":
- def __exit__(
- def __iter__(self) -> Iterator[_Part]:
- def __len__(self) -> int:
- def __bool__(self) -> bool:
- def _boundary_value(self) -> str:
- def boundary(self) -> str:
- def append(self, obj: Any, headers: Optional[MultiMapping[str]] = None) -> Payload:
- def append_payload(self, payload: Payload) -> Payload:
- def append_json(
- def append_form(
- def size(self) -> Optional[int]:
- class MultipartPayloadWriter:
- def __init__(self, writer: Any) -> None:
- def enable_encoding(self, encoding: str) -> None:
- def enable_compression(

venv\Lib\site-packages\aiohttp\payload.py
- class LookupError(Exception):
- class Order(str, enum.Enum):
- def get_payload(data: Any, *args: Any, **kwargs: Any) -> "Payload":
- def register_payload(
- class payload_type:
- def __init__(self, type: Any, *, order: Order = Order.normal) -> None:
- def __call__(self, factory: Type["Payload"]) -> Type["Payload"]:
- class PayloadRegistry:
- def __init__(self) -> None:
- def get(
- def register(
- class Payload(ABC):
- def __init__(
- def size(self) -> Optional[int]:
- def filename(self) -> Optional[str]:
- def headers(self) -> _CIMultiDict:
- def _binary_headers(self) -> bytes:
- def encoding(self) -> Optional[str]:
- def content_type(self) -> str:
- def set_content_disposition(
- class BytesPayload(Payload):
- def __init__(self, value: ByteString, *args: Any, **kwargs: Any) -> None:
- class StringPayload(BytesPayload):
- def __init__(
- class StringIOPayload(StringPayload):
- def __init__(self, value: IO[str], *args: Any, **kwargs: Any) -> None:
- class IOBasePayload(Payload):
- def __init__(
- class TextIOPayload(IOBasePayload):
- def __init__(
- def size(self) -> Optional[int]:
- class BytesIOPayload(IOBasePayload):
- def size(self) -> int:
- class BufferedReaderPayload(IOBasePayload):
- def size(self) -> Optional[int]:
# data.fileno() is not supported, e.g.
- class JsonPayload(BytesPayload):
- def __init__(
- class AsyncIterablePayload(Payload):
- def __init__(self, value: _AsyncIterable, *args: Any, **kwargs: Any) -> None:
- class StreamReaderPayload(AsyncIterablePayload):
- def __init__(self, value: StreamReader, *args: Any, **kwargs: Any) -> None:

venv\Lib\site-packages\aiohttp\payload_streamer.py
- class _stream_wrapper:
- def __init__(
- class streamer:
- def __init__(self, coro: Callable[..., Awaitable[None]]) -> None:
- def __call__(self, *args: Any, **kwargs: Any) -> _stream_wrapper:
- class StreamWrapperPayload(Payload):
- class StreamPayload(StreamWrapperPayload):
- def __init__(self, value: Any, *args: Any, **kwargs: Any) -> None:

venv\Lib\site-packages\aiohttp\pytest_plugin.py
- def pytest_addoption(parser):  # type: ignore[no-untyped-def]
- default=False,
- default="pyloop",
- default=False,
- def pytest_fixture_setup(fixturedef):  # type: ignore[no-untyped-def]
# async generator fixture
- def wrapper(*args, **kwargs):  # type: ignore[no-untyped-def]
- def finalizer():  # type: ignore[no-untyped-def]
- def fast(request):  # type: ignore[no-untyped-def]
- def loop_debug(request):  # type: ignore[no-untyped-def]
- def _runtime_warning_context():  # type: ignore[no-untyped-def]
- def _passthrough_loop_context(loop, fast=False):  # type: ignore[no-untyped-def]
- def pytest_pycollect_makeitem(collector, name, obj):  # type: ignore[no-untyped-def]
- def pytest_pyfunc_call(pyfuncitem):  # type: ignore[no-untyped-def]
- def pytest_generate_tests(metafunc):  # type: ignore[no-untyped-def]
- def loop(loop_factory, fast, loop_debug):  # type: ignore[no-untyped-def]
- def proactor_loop():  # type: ignore[no-untyped-def]
- def unused_port(aiohttp_unused_port):  # type: ignore[no-untyped-def] # pragma: no cover
- def aiohttp_unused_port():  # type: ignore[no-untyped-def]
- def aiohttp_server(loop):  # type: ignore[no-untyped-def]
- def test_server(aiohttp_server):  # type: ignore[no-untyped-def]  # pragma: no cover
- def aiohttp_raw_server(loop):  # type: ignore[no-untyped-def]
- def raw_test_server(  # type: ignore[no-untyped-def]  # pragma: no cover
- def aiohttp_client(
- def test_client(aiohttp_client):  # type: ignore[no-untyped-def]  # pragma: no cover

venv\Lib\site-packages\aiohttp\resolver.py
# aiodns_default = hasattr(aiodns.DNSResolver, 'gethostbyname')
- class ThreadedResolver(AbstractResolver):
- def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None) -> None:
- class AsyncResolver(AbstractResolver):
- def __init__(

venv\Lib\site-packages\aiohttp\streams.py
- class EofStream(Exception):
- class AsyncStreamIterator(Generic[_T]):
- def __init__(self, read_func: Callable[[], Awaitable[_T]]) -> None:
- def __aiter__(self) -> "AsyncStreamIterator[_T]":
- class ChunkTupleAsyncStreamIterator:
- def __init__(self, stream: "StreamReader") -> None:
- def __aiter__(self) -> "ChunkTupleAsyncStreamIterator":
- class AsyncStreamReaderMixin:
- def __aiter__(self) -> AsyncStreamIterator[bytes]:
- def iter_chunked(self, n: int) -> AsyncStreamIterator[bytes]:
- def iter_any(self) -> AsyncStreamIterator[bytes]:
- def iter_chunks(self) -> ChunkTupleAsyncStreamIterator:
- class StreamReader(AsyncStreamReaderMixin):
- def __init__(
- def __repr__(self) -> str:
- def get_read_buffer_limits(self) -> Tuple[int, int]:
- def exception(self) -> Optional[BaseException]:
- def set_exception(self, exc: BaseException) -> None:
- def on_eof(self, callback: Callable[[], None]) -> None:
- def feed_eof(self) -> None:
- def is_eof(self) -> bool:
- def at_eof(self) -> bool:
- def unread_data(self, data: bytes) -> None:
# TODO: size is ignored, remove the param later
- def feed_data(self, data: bytes, size: int = 0) -> None:
- def begin_http_chunk_receiving(self) -> None:
- def end_http_chunk_receiving(self) -> None:
- def read_nowait(self, n: int = -1) -> bytes:
- def _read_nowait_chunk(self, n: int) -> bytes:
- def _read_nowait(self, n: int) -> bytes:
- class EmptyStreamReader(StreamReader):  # lgtm [py/missing-call-to-init]
- def __init__(self) -> None:
- def exception(self) -> Optional[BaseException]:
- def set_exception(self, exc: BaseException) -> None:
- def on_eof(self, callback: Callable[[], None]) -> None:
- def feed_eof(self) -> None:
- def is_eof(self) -> bool:
- def at_eof(self) -> bool:
- def feed_data(self, data: bytes, n: int = 0) -> None:
- def read_nowait(self, n: int = -1) -> bytes:
- class DataQueue(Generic[_T]):
- def __init__(self, loop: asyncio.AbstractEventLoop) -> None:
- def __len__(self) -> int:
- def is_eof(self) -> bool:
- def at_eof(self) -> bool:
- def exception(self) -> Optional[BaseException]:
- def set_exception(self, exc: BaseException) -> None:
- def feed_data(self, data: _T, size: int = 0) -> None:
- def feed_eof(self) -> None:
- def __aiter__(self) -> AsyncStreamIterator[_T]:
- class FlowControlDataQueue(DataQueue[_T]):
- def __init__(
- def feed_data(self, data: _T, size: int = 0) -> None:

venv\Lib\site-packages\aiohttp\tcp_helpers.py
- def tcp_keepalive(transport: asyncio.Transport) -> None:
- def tcp_keepalive(transport: asyncio.Transport) -> None:  # pragma: no cover
- def tcp_nodelay(transport: asyncio.Transport, value: bool) -> None:
# socket may be closed already, on windows OSError get raised

venv\Lib\site-packages\aiohttp\test_utils.py
- def get_unused_port_socket(
- def get_port_socket(
# Windows has different semantics for SO_REUSEADDR,
- def unused_port() -> int:
- class BaseTestServer(ABC):
- def __init__(
- def make_url(self, path: str) -> URL:
- def started(self) -> bool:
- def closed(self) -> bool:
- def handler(self) -> Server:
- def __enter__(self) -> None:
- def __exit__(
- class TestServer(BaseTestServer):
- def __init__(
- class RawTestServer(BaseTestServer):
- def __init__(
- class TestClient:
- def __init__(
- def host(self) -> str:
- def port(self) -> Optional[int]:
- def server(self) -> BaseTestServer:
- def app(self) -> Optional[Application]:
- def session(self) -> ClientSession:
- def make_url(self, path: str) -> URL:
- def request(self, method: str, path: str, **kwargs: Any) -> _RequestContextManager:
- def get(self, path: str, **kwargs: Any) -> _RequestContextManager:
- def post(self, path: str, **kwargs: Any) -> _RequestContextManager:
- def options(self, path: str, **kwargs: Any) -> _RequestContextManager:
- def head(self, path: str, **kwargs: Any) -> _RequestContextManager:
- def put(self, path: str, **kwargs: Any) -> _RequestContextManager:
- def patch(self, path: str, **kwargs: Any) -> _RequestContextManager:
- def delete(self, path: str, **kwargs: Any) -> _RequestContextManager:
- def ws_connect(self, path: str, **kwargs: Any) -> _WSRequestContextManager:
- def __enter__(self) -> None:
- def __exit__(
- class AioHTTPTestCase(TestCase):
- def get_app(self) -> Application:
- def setUp(self) -> None:
- def tearDown(self) -> None:
- def unittest_run_loop(func: Any, *args: Any, **kwargs: Any) -> Any:
- def loop_context(
- def setup_test_loop(
- def teardown_test_loop(loop: asyncio.AbstractEventLoop, fast: bool = False) -> None:
- def _create_app_mock() -> mock.MagicMock:
- def get_dict(app: Any, key: str) -> Any:
- def set_dict(app: Any, key: str, value: Any) -> None:
- def _create_transport(sslcontext: Optional[SSLContext] = None) -> mock.Mock:
- def get_extra_info(key: str) -> Optional[SSLContext]:
- def make_mocked_request(
- def make_mocked_coro(

venv\Lib\site-packages\aiohttp\tracing.py
- class _SignalCallback(Protocol[_ParamT_contra]):
- def __call__(
- class TraceConfig:
- def __init__(
- def trace_config_ctx(
- def freeze(self) -> None:
- def on_request_start(self) -> "Signal[_SignalCallback[TraceRequestStartParams]]":
- def on_request_chunk_sent(
- def on_response_chunk_received(
- def on_request_end(self) -> "Signal[_SignalCallback[TraceRequestEndParams]]":
- def on_request_exception(
- def on_request_redirect(
- def on_connection_queued_start(
- def on_connection_queued_end(
- def on_connection_create_start(
- def on_connection_create_end(
- def on_connection_reuseconn(
- def on_dns_resolvehost_start(
- def on_dns_resolvehost_end(
- def on_dns_cache_hit(self) -> "Signal[_SignalCallback[TraceDnsCacheHitParams]]":
- def on_dns_cache_miss(self) -> "Signal[_SignalCallback[TraceDnsCacheMissParams]]":
- def on_request_headers_sent(
- class TraceRequestStartParams:
- class TraceRequestChunkSentParams:
- class TraceResponseChunkReceivedParams:
- class TraceRequestEndParams:
- class TraceRequestExceptionParams:
- class TraceRequestRedirectParams:
- class TraceConnectionQueuedStartParams:
- class TraceConnectionQueuedEndParams:
- class TraceConnectionCreateStartParams:
- class TraceConnectionCreateEndParams:
- class TraceConnectionReuseconnParams:
- class TraceDnsResolveHostStartParams:
- class TraceDnsResolveHostEndParams:
- class TraceDnsCacheHitParams:
- class TraceDnsCacheMissParams:
- class TraceRequestHeadersSentParams:
- class Trace:
- def __init__(

venv\Lib\site-packages\aiohttp\web.py
# web_app
- def _cancel_tasks(
- def run_app(
- def main(argv: List[str]) -> None:
- default="localhost",
- default="8080",

venv\Lib\site-packages\aiohttp\web_app.py
# No type checker mode, skip types
- class Application(MutableMapping[str, Any]):
- def __init__(
- def __init_subclass__(cls: Type["Application"]) -> None:
- def __setattr__(self, name: str, val: Any) -> None:
- def __eq__(self, other: object) -> bool:
- def __getitem__(self, key: str) -> Any:
- def _check_frozen(self) -> None:
- def __setitem__(self, key: str, value: Any) -> None:
- def __delitem__(self, key: str) -> None:
- def __len__(self) -> int:
- def __iter__(self) -> Iterator[str]:
- def loop(self) -> asyncio.AbstractEventLoop:
- def _set_loop(self, loop: Optional[asyncio.AbstractEventLoop]) -> None:
- def pre_frozen(self) -> bool:
- def pre_freeze(self) -> None:
- def frozen(self) -> bool:
- def freeze(self) -> None:
- def debug(self) -> bool:
- def _reg_subapp_signals(self, subapp: "Application") -> None:
- def reg_handler(signame: str) -> None:
- def add_subapp(self, prefix: str, subapp: "Application") -> AbstractResource:
- def _add_subapp(
- def add_domain(self, domain: str, subapp: "Application") -> AbstractResource:
- def add_routes(self, routes: Iterable[AbstractRouteDef]) -> List[AbstractRoute]:
- def on_response_prepare(self) -> _RespPrepareSignal:
- def on_startup(self) -> _AppSignal:
- def on_shutdown(self) -> _AppSignal:
- def on_cleanup(self) -> _AppSignal:
- def cleanup_ctx(self) -> "CleanupContext":
- def router(self) -> UrlDispatcher:
- def middlewares(self) -> _Middlewares:
- def _make_handler(
- def make_handler(
- def _make_request(
- def _prepare_middleware(self) -> Iterator[Tuple[_Middleware, bool]]:
- def __call__(self) -> "Application":
- def __repr__(self) -> str:
- def __bool__(self) -> bool:
- class CleanupError(RuntimeError):
- def exceptions(self) -> List[BaseException]:
- class CleanupContext(_CleanupContextBase):
- def __init__(self) -> None:

venv\Lib\site-packages\aiohttp\web_exceptions.py
# ###########################################################
- class HTTPException(Response, Exception):
- def __init__(
- def __bool__(self) -> bool:
- class HTTPError(HTTPException):
- class HTTPRedirection(HTTPException):
- class HTTPSuccessful(HTTPException):
- class HTTPOk(HTTPSuccessful):
- class HTTPCreated(HTTPSuccessful):
- class HTTPAccepted(HTTPSuccessful):
- class HTTPNonAuthoritativeInformation(HTTPSuccessful):
- class HTTPNoContent(HTTPSuccessful):
- class HTTPResetContent(HTTPSuccessful):
- class HTTPPartialContent(HTTPSuccessful):
- class _HTTPMove(HTTPRedirection):
- def __init__(
- class HTTPMultipleChoices(_HTTPMove):
- class HTTPMovedPermanently(_HTTPMove):
- class HTTPFound(_HTTPMove):
- class HTTPSeeOther(_HTTPMove):
- class HTTPNotModified(HTTPRedirection):
- class HTTPUseProxy(_HTTPMove):
- class HTTPTemporaryRedirect(_HTTPMove):
- class HTTPPermanentRedirect(_HTTPMove):
- class HTTPClientError(HTTPError):
- class HTTPBadRequest(HTTPClientError):
- class HTTPUnauthorized(HTTPClientError):
- class HTTPPaymentRequired(HTTPClientError):
- class HTTPForbidden(HTTPClientError):
- class HTTPNotFound(HTTPClientError):
- class HTTPMethodNotAllowed(HTTPClientError):
- def __init__(
- class HTTPNotAcceptable(HTTPClientError):
- class HTTPProxyAuthenticationRequired(HTTPClientError):
- class HTTPRequestTimeout(HTTPClientError):
- class HTTPConflict(HTTPClientError):
- class HTTPGone(HTTPClientError):
- class HTTPLengthRequired(HTTPClientError):
- class HTTPPreconditionFailed(HTTPClientError):
- class HTTPRequestEntityTooLarge(HTTPClientError):
- def __init__(self, max_size: float, actual_size: float, **kwargs: Any) -> None:
- class HTTPRequestURITooLong(HTTPClientError):
- class HTTPUnsupportedMediaType(HTTPClientError):
- class HTTPRequestRangeNotSatisfiable(HTTPClientError):
- class HTTPExpectationFailed(HTTPClientError):
- class HTTPMisdirectedRequest(HTTPClientError):
- class HTTPUnprocessableEntity(HTTPClientError):
- class HTTPFailedDependency(HTTPClientError):
- class HTTPUpgradeRequired(HTTPClientError):
- class HTTPPreconditionRequired(HTTPClientError):
- class HTTPTooManyRequests(HTTPClientError):
- class HTTPRequestHeaderFieldsTooLarge(HTTPClientError):
- class HTTPUnavailableForLegalReasons(HTTPClientError):
- def __init__(
- class HTTPServerError(HTTPError):
- class HTTPInternalServerError(HTTPServerError):
- class HTTPNotImplemented(HTTPServerError):
- class HTTPBadGateway(HTTPServerError):
- class HTTPServiceUnavailable(HTTPServerError):
- class HTTPGatewayTimeout(HTTPServerError):
- class HTTPVersionNotSupported(HTTPServerError):
- class HTTPVariantAlsoNegotiates(HTTPServerError):
- class HTTPInsufficientStorage(HTTPServerError):
- class HTTPNotExtended(HTTPServerError):
- class HTTPNetworkAuthenticationRequired(HTTPServerError):

venv\Lib\site-packages\aiohttp\web_fileresponse.py
- class FileResponse(StreamResponse):
- def __init__(
# To keep memory usage low,fobj is transferred in chunks
- def _strong_etag_match(etag_value: str, etags: Tuple[ETag, ...]) -> bool:

venv\Lib\site-packages\aiohttp\web_log.py
- class AccessLogger(AbstractAccessLogger):
- def __init__(self, logger: logging.Logger, log_format: str = LOG_FORMAT) -> None:
- def compile_format(self, log_format: str) -> Tuple[str, List[KeyMethod]]:
# list of (key, method) tuples, we don't use an OrderedDict as users
- def _format_i(
- def _format_o(
- def _format_a(request: BaseRequest, response: StreamResponse, time: float) -> str:
- def _format_t(request: BaseRequest, response: StreamResponse, time: float) -> str:
- def _format_P(request: BaseRequest, response: StreamResponse, time: float) -> str:
- def _format_r(request: BaseRequest, response: StreamResponse, time: float) -> str:
- def _format_s(request: BaseRequest, response: StreamResponse, time: float) -> int:
- def _format_b(request: BaseRequest, response: StreamResponse, time: float) -> int:
- def _format_T(request: BaseRequest, response: StreamResponse, time: float) -> str:
- def _format_Tf(request: BaseRequest, response: StreamResponse, time: float) -> str:
- def _format_D(request: BaseRequest, response: StreamResponse, time: float) -> str:
- def _format_line(
- def log(self, request: BaseRequest, response: StreamResponse, time: float) -> None:

venv\Lib\site-packages\aiohttp\web_middlewares.py
- def middleware(f: _Func) -> _Func:
- def normalize_path_middleware(
- def _fix_request_current_app(app: "Application") -> _Middleware:

venv\Lib\site-packages\aiohttp\web_protocol.py
- class RequestPayloadError(Exception):
- class PayloadAccessError(Exception):
- class _ErrInfo:
- class RequestHandler(BaseProtocol):
- def __init__(
# placeholder to be replaced on keepalive timeout setup
- def __repr__(self) -> str:
- def keepalive_timeout(self) -> float:
- def connection_made(self, transport: asyncio.BaseTransport) -> None:
- def connection_lost(self, exc: Optional[BaseException]) -> None:
- def set_parser(self, parser: Any) -> None:
- def eof_received(self) -> None:
- def data_received(self, data: bytes) -> None:
- def keep_alive(self, val: bool) -> None:
- def close(self) -> None:
- def force_close(self) -> None:
- def log_access(
- def log_debug(self, *args: Any, **kw: Any) -> None:
- def log_exception(self, *args: Any, **kw: Any) -> None:
- def _process_keepalive(self) -> None:
- def handle_error(
- def _make_error_handler(

venv\Lib\site-packages\aiohttp\web_request.py
- class FileField:
# '-' at the end to prevent interpretation as range in a char class
- class BaseRequest(MutableMapping[str, Any], HeadersMixin):
- def __init__(
- def clone(
- def task(self) -> "asyncio.Task[None]":
- def protocol(self) -> "RequestHandler":
- def transport(self) -> Optional[asyncio.Transport]:
- def writer(self) -> AbstractStreamWriter:
- def message(self) -> RawRequestMessage:
- def rel_url(self) -> URL:
- def loop(self) -> asyncio.AbstractEventLoop:
- def __getitem__(self, key: str) -> Any:
- def __setitem__(self, key: str, value: Any) -> None:
- def __delitem__(self, key: str) -> None:
- def __len__(self) -> int:
- def __iter__(self) -> Iterator[str]:
- def secure(self) -> bool:
- def forwarded(self) -> Tuple[Mapping[str, str], ...]:
- def scheme(self) -> str:
- def method(self) -> str:
- def version(self) -> HttpVersion:
- def host(self) -> str:
- def remote(self) -> Optional[str]:
- def url(self) -> URL:
- def path(self) -> str:
- def path_qs(self) -> str:
- def raw_path(self) -> str:
- def query(self) -> "MultiDictProxy[str]":
- def query_string(self) -> str:
- def headers(self) -> "CIMultiDictProxy[str]":
- def raw_headers(self) -> RawHeaders:
- def if_modified_since(self) -> Optional[datetime.datetime]:
- def if_unmodified_since(self) -> Optional[datetime.datetime]:
- def _etag_values(etag_header: str) -> Iterator[ETag]:
- def _if_match_or_none_impl(
- def if_match(self) -> Optional[Tuple[ETag, ...]]:
- def if_none_match(self) -> Optional[Tuple[ETag, ...]]:
- def if_range(self) -> Optional[datetime.datetime]:
- def keep_alive(self) -> bool:
- def cookies(self) -> Mapping[str, str]:
- def http_range(self) -> slice:
- def content(self) -> StreamReader:
- def has_body(self) -> bool:
- def can_read_body(self) -> bool:
- def body_exists(self) -> bool:
- def get_extra_info(self, name: str, default: Any = None) -> Any:
- def __repr__(self) -> str:
- def __eq__(self, other: object) -> bool:
- def __bool__(self) -> bool:
- def _cancel(self, exc: BaseException) -> None:
- class Request(BaseRequest):
- def __init__(self, *args: Any, **kwargs: Any) -> None:
- def __setattr__(self, name: str, val: Any) -> None:
- def clone(
- def match_info(self) -> "UrlMappingMatchInfo":
- def app(self) -> "Application":
- def config_dict(self) -> ChainMapProxy:

venv\Lib\site-packages\aiohttp\web_response.py
# allow samesite to be used in python < 3.8
- class ContentCoding(enum.Enum):
- deflate = "deflate"
- class StreamResponse(BaseClass, HeadersMixin):
- def __init__(
- def prepared(self) -> bool:
- def task(self) -> "Optional[asyncio.Task[None]]":
- def status(self) -> int:
- def chunked(self) -> bool:
- def compression(self) -> bool:
- def reason(self) -> str:
- def set_status(
- def keep_alive(self) -> Optional[bool]:
- def force_close(self) -> None:
- def body_length(self) -> int:
- def output_length(self) -> int:
- def enable_chunked_encoding(self, chunk_size: Optional[int] = None) -> None:
- def enable_compression(
- def headers(self) -> "CIMultiDict[str]":
- def cookies(self) -> "SimpleCookie[str]":
- def set_cookie(
- def del_cookie(
- def content_length(self) -> Optional[int]:
- def content_length(self, value: Optional[int]) -> None:
- def content_type(self) -> str:
- def content_type(self, value: str) -> None:
- def charset(self) -> Optional[str]:
- def charset(self, value: Optional[str]) -> None:
- def last_modified(self) -> Optional[datetime.datetime]:
- def last_modified(
- def etag(self) -> Optional[ETag]:
- def etag(self, value: Optional[Union[ETag, str]]) -> None:
- def _generate_content_type_header(
- def __repr__(self) -> str:
- def __getitem__(self, key: str) -> Any:
- def __setitem__(self, key: str, value: Any) -> None:
- def __delitem__(self, key: str) -> None:
- def __len__(self) -> int:
- def __iter__(self) -> Iterator[str]:
- def __hash__(self) -> int:
- def __eq__(self, other: object) -> bool:
- class Response(StreamResponse):
- def __init__(
- def body(self) -> Optional[Union[bytes, Payload]]:
- def body(
- def text(self) -> Optional[str]:
- def text(self, text: str) -> None:
- def content_length(self) -> Optional[int]:
- def content_length(self, value: Optional[int]) -> None:
- def _compress_body(self, zlib_mode: int) -> None:
- def json_response(

venv\Lib\site-packages\aiohttp\web_routedef.py
- class AbstractRouteDef(abc.ABC):
- def register(self, router: UrlDispatcher) -> List[AbstractRoute]:
- class RouteDef(AbstractRouteDef):
- def __repr__(self) -> str:
- def register(self, router: UrlDispatcher) -> List[AbstractRoute]:
- class StaticDef(AbstractRouteDef):
- def __repr__(self) -> str:
- def register(self, router: UrlDispatcher) -> List[AbstractRoute]:
- def route(method: str, path: str, handler: _HandlerType, **kwargs: Any) -> RouteDef:
- def head(path: str, handler: _HandlerType, **kwargs: Any) -> RouteDef:
- def options(path: str, handler: _HandlerType, **kwargs: Any) -> RouteDef:
- def get(
- def post(path: str, handler: _HandlerType, **kwargs: Any) -> RouteDef:
- def put(path: str, handler: _HandlerType, **kwargs: Any) -> RouteDef:
- def patch(path: str, handler: _HandlerType, **kwargs: Any) -> RouteDef:
- def delete(path: str, handler: _HandlerType, **kwargs: Any) -> RouteDef:
- def view(path: str, handler: Type[AbstractView], **kwargs: Any) -> RouteDef:
- def static(prefix: str, path: PathLike, **kwargs: Any) -> StaticDef:
- class RouteTableDef(Sequence[AbstractRouteDef]):
- def __init__(self) -> None:
- def __repr__(self) -> str:
- def __getitem__(self, index: int) -> AbstractRouteDef:
- def __getitem__(self, index: slice) -> List[AbstractRouteDef]:
- def __getitem__(self, index):  # type: ignore[no-untyped-def]
- def __iter__(self) -> Iterator[AbstractRouteDef]:
- def __len__(self) -> int:
- def __contains__(self, item: object) -> bool:
- def route(self, method: str, path: str, **kwargs: Any) -> _Deco:
- def inner(handler: _HandlerType) -> _HandlerType:
- def head(self, path: str, **kwargs: Any) -> _Deco:
- def get(self, path: str, **kwargs: Any) -> _Deco:
- def post(self, path: str, **kwargs: Any) -> _Deco:
- def put(self, path: str, **kwargs: Any) -> _Deco:
- def patch(self, path: str, **kwargs: Any) -> _Deco:
- def delete(self, path: str, **kwargs: Any) -> _Deco:
- def options(self, path: str, **kwargs: Any) -> _Deco:
- def view(self, path: str, **kwargs: Any) -> _Deco:
- def static(self, prefix: str, path: PathLike, **kwargs: Any) -> None:

venv\Lib\site-packages\aiohttp\web_runner.py
- class GracefulExit(SystemExit):
- def _raise_graceful_exit() -> None:
- class BaseSite(ABC):
- def __init__(
- def name(self) -> str:
# named pipes do not have wait_closed property
- class TCPSite(BaseSite):
- def __init__(
- def name(self) -> str:
- class UnixSite(BaseSite):
- def __init__(
- def name(self) -> str:
- class NamedPipeSite(BaseSite):
- def __init__(
- def name(self) -> str:
- class SockSite(BaseSite):
- def __init__(
- def name(self) -> str:
- class BaseRunner(ABC):
- def __init__(self, *, handle_signals: bool = False, **kwargs: Any) -> None:
- def server(self) -> Optional[Server]:
- def addresses(self) -> List[Any]:
- def sites(self) -> Set[BaseSite]:
- def _reg_site(self, site: BaseSite) -> None:
- def _check_site(self, site: BaseSite) -> None:
- def _unreg_site(self, site: BaseSite) -> None:
- class ServerRunner(BaseRunner):
- def __init__(
- class AppRunner(BaseRunner):
- def __init__(
- def app(self) -> Application:

venv\Lib\site-packages\aiohttp\web_server.py
- class Server:
- def __init__(
- def connections(self) -> List[RequestHandler]:
- def connection_made(
- def connection_lost(
- def _make_request(
- def __call__(self) -> RequestHandler:

venv\Lib\site-packages\aiohttp\web_urldispatcher.py
- class _InfoDict(TypedDict, total=False):
- class AbstractResource(Sized, Iterable["AbstractRoute"]):
- def __init__(self, *, name: Optional[str] = None) -> None:
- def name(self) -> Optional[str]:
- def canonical(self) -> str:
- def url_for(self, **kwargs: str) -> URL:
- def add_prefix(self, prefix: str) -> None:
- def get_info(self) -> _InfoDict:
- def freeze(self) -> None:
- def raw_match(self, path: str) -> bool:
- class AbstractRoute(abc.ABC):
- def __init__(
- def method(self) -> str:
- def handler(self) -> Handler:
- def name(self) -> Optional[str]:
- def resource(self) -> Optional[AbstractResource]:
- def get_info(self) -> _InfoDict:
- def url_for(self, *args: str, **kwargs: str) -> URL:
- class UrlMappingMatchInfo(BaseDict, AbstractMatchInfo):
- def __init__(self, match_dict: Dict[str, str], route: AbstractRoute):
- def handler(self) -> Handler:
- def route(self) -> AbstractRoute:
- def expect_handler(self) -> _ExpectHandler:
- def http_exception(self) -> Optional[HTTPException]:
- def get_info(self) -> _InfoDict:  # type: ignore[override]
- def apps(self) -> Tuple["Application", ...]:
- def add_app(self, app: "Application") -> None:
- def current_app(self) -> "Application":
- def set_current_app(self, app: "Application") -> Generator[None, None, None]:
- def freeze(self) -> None:
- def __repr__(self) -> str:
- class MatchInfoError(UrlMappingMatchInfo):
- def __init__(self, http_exception: HTTPException) -> None:
- def http_exception(self) -> HTTPException:
- def __repr__(self) -> str:
- class Resource(AbstractResource):
- def __init__(self, *, name: Optional[str] = None) -> None:
- def add_route(
- def register_route(self, route: "ResourceRoute") -> None:
- def _match(self, path: str) -> Optional[Dict[str, str]]:
- def __len__(self) -> int:
- def __iter__(self) -> Iterator[AbstractRoute]:
# TODO: implement all abstract methods
- class PlainResource(Resource):
- def __init__(self, path: str, *, name: Optional[str] = None) -> None:
- def canonical(self) -> str:
- def freeze(self) -> None:
- def add_prefix(self, prefix: str) -> None:
- def _match(self, path: str) -> Optional[Dict[str, str]]:
- def raw_match(self, path: str) -> bool:
- def get_info(self) -> _InfoDict:
- def url_for(self) -> URL:  # type: ignore[override]
- def __repr__(self) -> str:
- class DynamicResource(Resource):
- def __init__(self, path: str, *, name: Optional[str] = None) -> None:
- def canonical(self) -> str:
- def add_prefix(self, prefix: str) -> None:
- def _match(self, path: str) -> Optional[Dict[str, str]]:
- def raw_match(self, path: str) -> bool:
- def get_info(self) -> _InfoDict:
- def url_for(self, **parts: str) -> URL:
- def __repr__(self) -> str:
- class PrefixResource(AbstractResource):
- def __init__(self, prefix: str, *, name: Optional[str] = None) -> None:
- def canonical(self) -> str:
- def add_prefix(self, prefix: str) -> None:
- def raw_match(self, prefix: str) -> bool:
- class StaticResource(PrefixResource):
- def __init__(
- def url_for(  # type: ignore[override]
- def _get_file_hash(byte_array: bytes) -> str:
- def get_info(self) -> _InfoDict:
- def set_options_route(self, handler: Handler) -> None:
- def __len__(self) -> int:
- def __iter__(self) -> Iterator[AbstractRoute]:
- def _directory_as_html(self, filepath: Path) -> str:
- def __repr__(self) -> str:
- class PrefixedSubAppResource(PrefixResource):
- def __init__(self, prefix: str, app: "Application") -> None:
- def add_prefix(self, prefix: str) -> None:
- def url_for(self, *args: str, **kwargs: str) -> URL:
- def get_info(self) -> _InfoDict:
- def __len__(self) -> int:
- def __iter__(self) -> Iterator[AbstractRoute]:
- def __repr__(self) -> str:
- class AbstractRuleMatching(abc.ABC):
- def get_info(self) -> _InfoDict:
- def canonical(self) -> str:
- class Domain(AbstractRuleMatching):
- def __init__(self, domain: str) -> None:
- def canonical(self) -> str:
- def validation(self, domain: str) -> str:
- def match_domain(self, host: str) -> bool:
- def get_info(self) -> _InfoDict:
- class MaskDomain(Domain):
- def __init__(self, domain: str) -> None:
- def canonical(self) -> str:
- def match_domain(self, host: str) -> bool:
- class MatchedSubAppResource(PrefixedSubAppResource):
- def __init__(self, rule: AbstractRuleMatching, app: "Application") -> None:
- def canonical(self) -> str:
- def get_info(self) -> _InfoDict:
- def __repr__(self) -> str:
- class ResourceRoute(AbstractRoute):
- def __init__(
- def __repr__(self) -> str:
- def name(self) -> Optional[str]:
- def url_for(self, *args: str, **kwargs: str) -> URL:
- def get_info(self) -> _InfoDict:
- class SystemRoute(AbstractRoute):
- def __init__(self, http_exception: HTTPException) -> None:
- def url_for(self, *args: str, **kwargs: str) -> URL:
- def name(self) -> Optional[str]:
- def get_info(self) -> _InfoDict:
- def status(self) -> int:
- def reason(self) -> str:
- def __repr__(self) -> str:
- class View(AbstractView):
- def __await__(self) -> Generator[Any, None, StreamResponse]:
- def _raise_allowed_methods(self) -> None:
- class ResourcesView(Sized, Iterable[AbstractResource], Container[AbstractResource]):
- def __init__(self, resources: List[AbstractResource]) -> None:
- def __len__(self) -> int:
- def __iter__(self) -> Iterator[AbstractResource]:
- def __contains__(self, resource: object) -> bool:
- class RoutesView(Sized, Iterable[AbstractRoute], Container[AbstractRoute]):
- def __init__(self, resources: List[AbstractResource]):
- def __len__(self) -> int:
- def __iter__(self) -> Iterator[AbstractRoute]:
- def __contains__(self, route: object) -> bool:
- class UrlDispatcher(AbstractRouter, Mapping[str, AbstractResource]):
- def __init__(self) -> None:
- def __iter__(self) -> Iterator[str]:
- def __len__(self) -> int:
- def __contains__(self, resource: object) -> bool:
- def __getitem__(self, name: str) -> AbstractResource:
- def resources(self) -> ResourcesView:
- def routes(self) -> RoutesView:
- def named_resources(self) -> Mapping[str, AbstractResource]:
- def register_resource(self, resource: AbstractResource) -> None:
- def add_resource(self, path: str, *, name: Optional[str] = None) -> Resource:
- def add_route(
- def add_static(
- def add_head(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
- def add_options(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
- def add_get(
- def add_post(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
- def add_put(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
- def add_patch(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
- def add_delete(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
- def add_view(
- def freeze(self) -> None:
- def add_routes(self, routes: Iterable[AbstractRouteDef]) -> List[AbstractRoute]:
- def _quote_path(value: str) -> str:
- def _unquote_path(value: str) -> str:
- def _requote_path(value: str) -> str:

venv\Lib\site-packages\aiohttp\web_ws.py
- class WebSocketReady:
- def __bool__(self) -> bool:
- class WebSocketResponse(StreamResponse):
- def __init__(
- def _cancel_heartbeat(self) -> None:
- def _reset_heartbeat(self) -> None:
- def _send_heartbeat(self) -> None:
# fire-and-forget a task is not perfect but maybe ok for
- def _pong_not_received(self) -> None:
- def _handshake(
- def _pre_start(self, request: BaseRequest) -> Tuple[str, WebSocketWriter]:
- def _post_start(
- def can_prepare(self, request: BaseRequest) -> WebSocketReady:
- def closed(self) -> bool:
- def close_code(self) -> Optional[int]:
- def ws_protocol(self) -> Optional[str]:
- def compress(self) -> bool:
- def exception(self) -> Optional[BaseException]:
- def __aiter__(self) -> "WebSocketResponse":
- def _cancel(self, exc: BaseException) -> None:

venv\Lib\site-packages\aiohttp\worker.py
- class GunicornWebWorker(base.Worker):  # type: ignore[misc,no-any-unimported]
- def __init__(self, *args: Any, **kw: Any) -> None:  # pragma: no cover
- def init_process(self) -> None:
# create new event_loop after fork
- def run(self) -> None:
- def _wait_next_notify(self) -> "asyncio.Future[bool]":
- def _notify_waiter_done(
- def init_signals(self) -> None:
- def handle_quit(self, sig: int, frame: FrameType) -> None:
- def handle_abort(self, sig: int, frame: FrameType) -> None:
- def _create_ssl_context(cfg: Any) -> "SSLContext":
- def _get_valid_log_format(self, source_format: str) -> str:
- class GunicornUVLoopWebWorker(GunicornWebWorker):
- def init_process(self) -> None:
- class GunicornTokioWebWorker(GunicornWebWorker):
- def init_process(self) -> None:  # pragma: no cover

venv\Lib\site-packages\aiosignal\__init__.py
- class Signal(FrozenList):
- def __init__(self, owner):
- def __repr__(self):

venv\Lib\site-packages\altair\datasets.py
- def load_dataset(name):
- def list_datasets():

venv\Lib\site-packages\altair\_magics.py
# Vega doesn't yet have specific data transformers; use vegalite
- def _prepare_data(data, data_transformers):
- def _get_variable(name):
- def vega(line, cell):
- def namevar(s):
- def vegalite(line, cell):

venv\Lib\site-packages\altair\__init__.py
# flake8: noqa
- def load_ipython_extension(ipython):

